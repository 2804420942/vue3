"use strict";(self["webpackChunkvue3"]=self["webpackChunkvue3"]||[]).push([[127],{5127:function(t,e,n){n.d(e,{M:function(){return te},b:function(){return ee},c:function(){return ne}});n(8675),n(3462),n(1703),n(2262),n(4506);var s=n(9260),o=Object.defineProperty,r=Object.defineProperties,i=Object.getOwnPropertyDescriptors,a=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,u=(t,e,n)=>e in t?o(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,d=(t,e)=>{for(var n in e||(e={}))c.call(e,n)&&u(t,n,e[n]);if(a)for(var n of a(e))l.call(e,n)&&u(t,n,e[n]);return t},f=(t,e)=>r(t,i(e));const p=0,h=1,y=2,g=2,m=1.25,w=1,x=32,b=65535,B=Math.pow(2,-24);class P{constructor(){}}function T(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function M(t){let e=-1,n=-1/0;for(let s=0;s<3;s++){const o=t[s+3]-t[s];o>n&&(n=o,e=s)}return e}function A(t,e){e.set(t)}function V(t,e,n){let s,o;for(let r=0;r<3;r++){const i=r+3;s=t[r],o=e[r],n[r]=s<o?s:o,s=t[i],o=e[i],n[i]=s>o?s:o}}function v(t,e,n){for(let s=0;s<3;s++){const o=e[t+2*s],r=e[t+2*s+1],i=o-r,a=o+r;i<n[s]&&(n[s]=i),a>n[s+3]&&(n[s+3]=a)}}function S(t){const e=t[3]-t[0],n=t[4]-t[1],s=t[5]-t[2];return 2*(e*n+n*s+s*e)}function U(t,e){if(!t.index){const n=t.attributes.position.count,o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=n>65535?new Uint32Array(new o(4*n)):new Uint16Array(new o(2*n)),t.setIndex(new s.ak(r,1));for(let t=0;t<n;t++)r[t]=t}}function F(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const o of t.groups)n.add(o.start),n.add(o.start+o.count);const s=Array.from(n.values()).sort(((t,e)=>t-e));for(let o=0;o<s.length-1;o++){const t=s[o],n=s[o+1];e.push({offset:t/3,count:(n-t)/3})}return e}function z(t,e,n,s,o=null){let r=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,y=-1/0,g=-1/0;const m=null!==o;for(let w=6*e,x=6*(e+n);w<x;w+=6){const e=t[w+0],n=t[w+1],s=e-n,o=e+n;s<r&&(r=s),o>c&&(c=o),m&&e<d&&(d=e),m&&e>h&&(h=e);const x=t[w+2],b=t[w+3],B=x-b,P=x+b;B<i&&(i=B),P>l&&(l=P),m&&x<f&&(f=x),m&&x>y&&(y=x);const T=t[w+4],M=t[w+5],A=T-M,V=T+M;A<a&&(a=A),V>u&&(u=V),m&&T<p&&(p=T),m&&T>g&&(g=T)}s[0]=r,s[1]=i,s[2]=a,s[3]=c,s[4]=l,s[5]=u,m&&(o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=y,o[5]=g)}function I(t,e,n,s){let o=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0;for(let u=6*e,d=6*(e+n);u<d;u+=6){const e=t[u+0];e<o&&(o=e),e>a&&(a=e);const n=t[u+2];n<r&&(r=n),n>c&&(c=n);const s=t[u+4];s<i&&(i=s),s>l&&(l=s)}s[0]=o,s[1]=r,s[2]=i,s[3]=a,s[4]=c,s[5]=l}function _(t,e,n,s,o){let r=n,i=n+s-1;const a=o.pos,c=2*o.axis;while(1){while(r<=i&&e[6*r+c]<a)r++;while(r<=i&&e[6*i+c]>=a)i--;if(!(r<i))return r;for(let n=0;n<3;n++){let s=t[3*r+n];t[3*r+n]=t[3*i+n],t[3*i+n]=s;let o=e[6*r+2*n+0];e[6*r+2*n+0]=e[6*i+2*n+0],e[6*i+2*n+0]=o;let a=e[6*r+2*n+1];e[6*r+2*n+1]=e[6*i+2*n+1],e[6*i+2*n+1]=a}r++,i--}}const q=32,C=(t,e)=>t.candidate-e.candidate,E=new Array(q).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),O=new Float32Array(6);function k(t,e,n,s,o,r){let i=-1,a=0;if(r===p)i=M(e),-1!==i&&(a=(e[i]+e[i+3])/2);else if(r===h)i=M(t),-1!==i&&(a=H(n,s,o,i));else if(r===y){const r=S(t);let c=m*o;const l=6*s,u=6*(s+o);for(let t=0;t<3;t++){const s=e[t],d=e[t+3],f=d-s,p=f/q;if(o<q/4){const e=[...E];e.length=o;let s=0;for(let o=l;o<u;o+=6,s++){const r=e[s];r.candidate=n[o+2*t],r.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=r;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;v(o,n,i)}e.sort(C);let d=o;for(let t=0;t<d;t++){const n=e[t];while(t+1<d&&e[t+1].candidate===n.candidate)e.splice(t+1,1),d--}for(let o=l;o<u;o+=6){const s=n[o+2*t];for(let t=0;t<d;t++){const r=e[t];s>=r.candidate?v(o,n,r.rightCacheBounds):(v(o,n,r.leftCacheBounds),r.count++)}}for(let n=0;n<d;n++){const s=e[n],l=s.count,u=o-s.count,d=s.leftCacheBounds,f=s.rightCacheBounds;let p=0;0!==l&&(p=S(d)/r);let h=0;0!==u&&(h=S(f)/r);const y=w+m*(p*l+h*u);y<c&&(i=t,c=y,a=s.candidate)}}else{for(let t=0;t<q;t++){const e=E[t];e.count=0,e.candidate=s+p+t*p;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=l;o<u;o+=6){const e=n[o+2*t],r=e-s;let i=~~(r/p);i>=q&&(i=q-1);const a=E[i];a.count++,v(o,n,a.bounds)}const e=E[q-1];A(e.bounds,e.rightCacheBounds);for(let t=q-2;t>=0;t--){const e=E[t],n=E[t+1];V(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let n=0;n<q-1;n++){const e=E[n],s=e.count,l=e.bounds,u=E[n+1],f=u.rightCacheBounds;0!==s&&(0===d?A(l,O):V(l,O,O)),d+=s;let p=0,h=0;0!==d&&(p=S(O)/r);const y=o-d;0!==y&&(h=S(f)/r);const g=w+m*(p*d+h*y);g<c&&(i=t,c=g,a=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:i,pos:a}}function H(t,e,n,s){let o=0;for(let r=e,i=e+n;r<i;r++)o+=t[6*r+2*s];return o/n}function D(t,e){const n=t.attributes.position,s=n.array,o=t.index.array,r=o.length/3,i=new Float32Array(6*r),a=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);for(let l=0;l<r;l++){const t=3*l,n=6*l,r=o[t+0]*c+a,u=o[t+1]*c+a,d=o[t+2]*c+a;for(let o=0;o<3;o++){const t=s[r+o],a=s[u+o],c=s[d+o];let l=t;a<l&&(l=a),c<l&&(l=c);let f=t;a>f&&(f=a),c>f&&(f=c);const p=(f-l)/2,h=2*o;i[n+h+0]=l+p,i[n+h+1]=p+(Math.abs(l)+p)*B,l<e[o]&&(e[o]=l),f>e[o+3]&&(e[o+3]=f)}}return i}function j(t,e){function n(t){f&&f(t/p)}function s(e,o,f,p=null,y=0){if(!h&&y>=c&&(h=!0,l&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),f<=u||y>=c)return n(o),e.offset=o,e.count=f,e;const g=k(e.boundingData,p,i,o,f,d);if(-1===g.axis)return n(o),e.offset=o,e.count=f,e;const m=_(a,i,o,f,g);if(m===o||m===o+f)n(o),e.offset=o,e.count=f;else{e.splitAxis=g.axis;const t=new P,n=o,a=m-o;e.left=t,t.boundingData=new Float32Array(6),z(i,n,a,t.boundingData,r),s(t,n,a,r,y+1);const c=new P,l=m,u=f-a;e.right=c,c.boundingData=new Float32Array(6),z(i,l,u,c.boundingData,r),s(c,l,u,r,y+1)}return e}U(t,e);const o=new Float32Array(6),r=new Float32Array(6),i=D(t,o),a=t.index.array,c=e.maxDepth,l=e.verbose,u=e.maxLeafTris,d=e.strategy,f=e.onProgress,p=t.index.count/3;let h=!1;const y=[],g=F(t);if(1===g.length){const t=g[0],e=new P;e.boundingData=o,I(i,t.offset,t.count,r),s(e,t.offset,t.count,r),y.push(e)}else for(let m of g){const t=new P;t.boundingData=new Float32Array(6),z(i,m.offset,m.count,t.boundingData,r),s(t,m.offset,m.count,r),y.push(t)}return y}function G(t,e){const n=j(t,e);let s,o,r;const i=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<n.length;u++){const t=n[u];let e=c(t);const d=new a(x*e);s=new Float32Array(d),o=new Uint32Array(d),r=new Uint16Array(d),l(0,t),i.push(d)}return i;function c(t){return t.count?1:1+c(t.left)+c(t.right)}function l(t,e){const n=t/4,i=t/2,a=!!e.count,c=e.boundingData;for(let o=0;o<6;o++)s[n+o]=c[o];if(a){const s=e.offset,a=e.count;return o[n+6]=s,r[i+14]=a,r[i+15]=b,t+x}{const s=e.left,r=e.right,i=e.splitAxis;let a;if(a=l(t+x,s),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return o[n+6]=a/4,a=l(a,r),o[n+7]=i,a}}}class X{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let o=0,r=t.length;o<r;o++){const r=t[o],i=r[e];n=i<n?i:n,s=i>s?i:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let o=0,r=e.length;o<r;o++){const r=e[o],i=t.dot(r);n=i<n?i:n,s=i>s?i:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}X.prototype.setFromBox=function(){const t=new s.V;return function(e,n){const s=n.min,o=n.max;let r=1/0,i=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=s.x*a+o.x*(1-a),t.y=s.y*n+o.y*(1-n),t.z=s.z*c+o.z*(1-c);const l=e.dot(t);r=Math.min(l,r),i=Math.max(l,i)}this.min=r,this.max=i}}(),function(){const t=new X}();const L=function(){const t=new s.V,e=new s.V,n=new s.V;return function(s,o,r){const i=s.start,a=t,c=o.start,l=e;n.subVectors(i,c),t.subVectors(s.end,o.start),e.subVectors(o.end,o.start);const u=n.dot(l),d=l.dot(a),f=l.dot(l),p=n.dot(a),h=a.dot(a),y=h*f-d*d;let g,m;g=0!==y?(u*d-p*f)/y:0,m=(u+g*d)/f,r.x=g,r.y=m}}(),W=function(){const t=new s.a4,e=new s.V,n=new s.V;return function(s,o,r,i){L(s,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return s.at(a,r),void o.at(c,i);if(a>=0&&a<=1)return c<0?o.at(0,i):o.at(1,i),void s.closestPointToPoint(i,!0,r);if(c>=0&&c<=1)return a<0?s.at(0,r):s.at(1,r),void o.closestPointToPoint(r,!0,i);{let t,l;t=a<0?s.start:s.end,l=c<0?o.start:o.end;const u=e,d=n;return s.closestPointToPoint(l,!0,e),o.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=d.distanceToSquared(t)?(r.copy(u),void i.copy(l)):(r.copy(t),void i.copy(d))}}}(),R=function(){const t=new s.V,e=new s.V,n=new s.aT,o=new s.aU;return function(s,r){const{radius:i,center:a}=s,{a:c,b:l,c:u}=r;o.start=c,o.end=l;const d=o.closestPointToPoint(a,!0,t);if(d.distanceTo(a)<=i)return!0;o.start=c,o.end=u;const f=o.closestPointToPoint(a,!0,t);if(f.distanceTo(a)<=i)return!0;o.start=l,o.end=u;const p=o.closestPointToPoint(a,!0,t);if(p.distanceTo(a)<=i)return!0;const h=r.getPlane(n),y=Math.abs(h.distanceToPoint(a));if(y<=i){const t=h.projectPoint(a,e),n=r.containsPoint(t);if(n)return!0}return!1}}();class N extends s.aV{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new s.V)),this.satBounds=new Array(4).fill().map((()=>new X)),this.points=[this.a,this.b,this.c],this.sphere=new s.au,this.plane=new s.aT,this.needsUpdate=!1}intersectsSphere(t){return R(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,o=this.satAxes,r=this.satBounds,i=o[0],a=r[0];this.getNormal(i),a.setFromPoints(i,s);const c=o[1],l=r[1];c.subVectors(t,e),l.setFromPoints(c,s);const u=o[2],d=r[2];u.subVectors(e,n),d.setFromPoints(u,s);const f=o[3],p=r[3];f.subVectors(n,t),p.setFromPoints(f,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}N.prototype.closestPointToSegment=function(){const t=new s.V,e=new s.V,n=new s.aU;return function(s,o=null,r=null){const{start:i,end:a}=s,c=this.points;let l,u=1/0;for(let d=0;d<3;d++){const i=(d+1)%3;n.start.copy(c[d]),n.end.copy(c[i]),W(n,s,t,e),l=t.distanceToSquared(e),l<u&&(u=l,o&&o.copy(t),r&&r.copy(e))}return this.closestPointToPoint(i,t),l=i.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),r&&r.copy(i)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),r&&r.copy(a)),Math.sqrt(u)}}(),N.prototype.intersectsTriangle=function(){const t=new N,e=new Array(3),n=new Array(3),o=new X,r=new X,i=new s.V,a=new s.V,c=new s.V,l=new s.V,u=new s.aU,d=new s.aU,f=new s.aU;return function(s,p=null){this.needsUpdate&&this.update(),s.isSeparatingAxisTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const h=this.satBounds,y=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let t=0;t<4;t++){const e=h[t],s=y[t];if(o.setFromPoints(s,n),e.isSeparated(o))return!1}const g=s.satBounds,m=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=g[t],s=m[t];if(o.setFromPoints(s,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const s=y[t];for(let t=0;t<4;t++){const a=m[t];if(i.crossVectors(s,a),o.setFromPoints(i,e),r.setFromPoints(i,n),o.isSeparated(r))return!1}}if(p){const t=this.plane,e=s.plane;if(Math.abs(t.normal.dot(e.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0);else{const n=this.points;let o=!1;for(let t=0;t<3;t++){const s=n[t],r=n[(t+1)%3];if(u.start.copy(s),u.end.copy(r),e.intersectLine(u,o?d.start:d.end)){if(o)break;o=!0}}const r=s.points;let i=!1;for(let e=0;e<3;e++){const n=r[e],s=r[(e+1)%3];if(u.start.copy(n),u.end.copy(s),t.intersectLine(u,i?f.start:f.end)){if(i)break;i=!0}}if(d.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}l.subVectors(d.start,f.start),l.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),l.subVectors(d.end,f.end),l.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)}}return!0}}(),N.prototype.distanceToPoint=function(){const t=new s.V;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),N.prototype.distanceToTriangle=function(){const t=new s.V,e=new s.V,n=["a","b","c"],o=new s.aU,r=new s.aU;return function(s,i=null,a=null){const c=i||a?o:null;if(this.intersectsTriangle(s,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let o;const r=n[e],c=s[r];this.closestPointToPoint(c,t),o=c.distanceToSquared(t),o<l&&(l=o,i&&i.copy(t),a&&a.copy(c));const u=this[r];s.closestPointToPoint(u,t),o=u.distanceToSquared(t),o<l&&(l=o,i&&i.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];o.set(this[c],this[d]);for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];r.set(s[c],s[d]),W(o,r,t,e);const f=t.distanceToSquared(e);f<l&&(l=f,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class Y extends s.at{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new s.M,this.invMatrix=new s.M,this.points=new Array(8).fill().map((()=>new s.V)),this.satAxes=new Array(3).fill().map((()=>new s.V)),this.satBounds=new Array(3).fill().map((()=>new X)),this.alignedSatBounds=new Array(3).fill().map((()=>new X)),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix=n,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Y.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let r=0;r<=1;r++){const i=1*c|2*o|4*r,a=s[i];a.x=c?n.x:e.x,a.y=o?n.y:e.y,a.z=r?n.z:e.z,a.applyMatrix4(t)}const o=this.satBounds,r=this.satAxes,i=s[0];for(let c=0;c<3;c++){const t=r[c],e=o[c],n=1<<c,a=s[n];t.subVectors(i,a),e.setFromPoints(t,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Y.prototype.intersectsBox=function(){const t=new X;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,o=this.satBounds,r=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=s.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=s.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=s.z,i[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=r[a],s=o[a];if(t.setFromBox(n,e),s.isSeparated(t))return!1}return!0}}(),Y.prototype.intersectsTriangle=function(){const t=new N,e=new Array(3),n=new X,o=new X,r=new s.V;return function(s){this.needsUpdate&&this.update(),s.isSeparatingAxisTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const i=this.satBounds,a=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const s=i[t],o=a[t];if(n.setFromPoints(o,e),s.isSeparated(n))return!1}const c=s.satBounds,l=s.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],s=l[t];if(n.setFromPoints(s,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const s=a[t];for(let t=0;t<4;t++){const i=l[t];if(r.crossVectors(s,i),n.setFromPoints(r,e),o.setFromPoints(r,u),n.isSeparated(o))return!1}}return!0}}(),Y.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),Y.prototype.distanceToPoint=function(){const t=new s.V;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Y.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new s.aU)),n=new Array(12).fill().map((()=>new s.aU)),o=new s.V,r=new s.V;return function(s,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(a||c)&&(s.getCenter(r),this.closestPointToPoint(r,o),s.closestPointToPoint(o,r),a&&a.copy(o),c&&c.copy(r)),0;const l=i*i,u=s.min,d=s.max,f=this.points;let p=1/0;for(let t=0;t<8;t++){const e=f[t];r.copy(e).clamp(u,d);const n=e.distanceToSquared(r);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(r),n<l))return Math.sqrt(n)}let h=0;for(let o=0;o<3;o++)for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){const i=(o+1)%3,a=(o+2)%3,c=s<<i|r<<a,l=1<<o|s<<i|r<<a,p=f[c],y=f[l],g=e[h];g.set(p,y);const m=t[o],w=t[i],x=t[a],b=n[h],B=b.start,P=b.end;B[m]=u[m],B[w]=s?u[w]:d[w],B[x]=r?u[x]:d[w],P[m]=d[m],P[w]=s?u[w]:d[w],P[x]=r?u[x]:d[w],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){r.x=t?d.x:u.x,r.y=e?d.y:u.y,r.z=n?d.z:u.z,this.closestPointToPoint(r,o);const s=r.distanceToSquared(o);if(s<p&&(p=s,a&&a.copy(o),c&&c.copy(r),s<l))return Math.sqrt(s)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=n[t];W(s,e,o,r);const i=o.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(o),c&&c.copy(r),i<l))return Math.sqrt(i)}}return Math.sqrt(p)}}();const Z=new s.V,$=new s.V,J=new s.V,K=new s.a4,Q=new s.a4,tt=new s.a4,et=new s.V;function nt(t,e,n,o,r,i){let a;if(a=i===s.aW?t.intersectTriangle(o,n,e,!0,r):t.intersectTriangle(e,n,o,i!==s.D,r),null===a)return null;const c=t.origin.distanceTo(r);return{distance:c,point:r.clone()}}function st(t,e,n,o,r,i,a){Z.fromBufferAttribute(e,o),$.fromBufferAttribute(e,r),J.fromBufferAttribute(e,i);const c=nt(t,Z,$,J,et,a);if(c){n&&(K.fromBufferAttribute(n,o),Q.fromBufferAttribute(n,r),tt.fromBufferAttribute(n,i),c.uv=s.aV.getUV(et,Z,$,J,K,Q,tt,new s.a4));const t={a:o,b:r,c:i,normal:new s.V,materialIndex:0};s.aV.getNormal(Z,$,J,t.normal),c.face=t,c.faceIndex=o}return c}function ot(t,e,n,s,o){const r=3*s,i=t.index.getX(r),a=t.index.getX(r+1),c=t.index.getX(r+2),l=st(n,t.attributes.position,t.attributes.uv,i,a,c,e);return l?(l.faceIndex=s,o&&o.push(l),l):null}function rt(t,e,n,s,o,r){for(let i=s,a=s+o;i<a;i++)ot(t,e,n,i,r)}function it(t,e,n,s,o){let r=1/0,i=null;for(let a=s,c=s+o;a<c;a++){const s=ot(t,e,n,a);s&&s.distance<r&&(i=s,r=s.distance)}return i}function at(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}function ct(t,e,n,s){const o=t.a,r=t.b,i=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(e),c=n.getX(e+1),l=n.getX(e+2)),o.x=s.getX(a),o.y=s.getY(a),o.z=s.getZ(a),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l)}function lt(t,e,n,s,o,r,i){const a=n.index,c=n.attributes.position;for(let l=t,u=e+t;l<u;l++)if(ct(i,3*l,a,c),i.needsUpdate=!0,s(i,l,o,r))return!0;return!1}class ut{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function dt(t,e){return 65535===e[t+15]}function ft(t,e){return e[t+6]}function pt(t,e){return e[t+14]}function ht(t){return t+8}function yt(t,e){return e[t+6]}function gt(t,e){return e[t+7]}function mt(t){return t}const wt=new s.at,xt=new s.V,bt=["x","y","z"];function Bt(t,e,n,s,o){let r=2*t,i=St,a=Ut,c=Ft;const l=dt(r,a);if(l){const i=ft(t,c),l=pt(r,a);rt(e,n,s,i,l,o)}else{const r=ht(t);At(r,i,s,xt)&&Bt(r,e,n,s,o);const a=yt(t,c);At(a,i,s,xt)&&Bt(a,e,n,s,o)}}function Pt(t,e,n,s){let o=2*t,r=St,i=Ut,a=Ft;const c=dt(o,i);if(c){const r=ft(t,a),c=pt(o,i);return it(e,n,s,r,c)}{const o=gt(t,a),i=bt[o],c=s.direction[i],l=c>=0;let u,d;l?(u=ht(t),d=yt(t,a)):(u=yt(t,a),d=ht(t));const f=At(u,r,s,xt),p=f?Pt(u,e,n,s):null;if(p){const t=p.point[i],e=l?t<=r[d+o]:t>=r[d+o+3];if(e)return p}const h=At(d,r,s,xt),y=h?Pt(d,e,n,s):null;return p&&y?p.distance<=y.distance?p:y:p||y||null}}const Tt=function(){let t,e;const n=[],o=new ut((()=>new s.at));return function(...s){t=o.getPrimitive(),e=o.getPrimitive(),n.push(t,e);const i=r(...s);o.releasePrimitive(t),o.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),i};function r(n,s,o,i,a=null,c=0,l=0){function u(t){let e=2*t,n=Ut,s=Ft;while(!dt(e,n))t=ht(t),e=2*t;return ft(t,s)}function d(t){let e=2*t,n=Ut,s=Ft;while(!dt(e,n))t=yt(t,s),e=2*t;return ft(t,s)+pt(e,n)}let f=2*n,p=St,h=Ut,y=Ft;const m=dt(f,h);if(m){const e=ft(n,y),s=pt(f,h);return T(mt(n),p,t),i(e,s,!1,l,c+n,t)}{const f=ht(n),m=yt(n,y);let w,x,b,B,P=f,M=m;if(a&&(b=t,B=e,T(mt(P),p,b),T(mt(M),p,B),w=a(b),x=a(B),x<w)){P=m,M=f;const t=w;w=x,x=t,b=B}b||(b=t,T(mt(P),p,b));const A=dt(2*P,h),V=o(b,A,w,l+1,c+P);let v;if(V===g){const t=u(P),e=d(P),n=e-t;v=i(t,n,!0,l+1,c+P,b)}else v=V&&r(P,s,o,i,a,c,l+1);if(v)return!0;B=e,T(mt(M),p,B);const S=dt(2*M,h),U=o(B,S,x,l+1,c+M);let F;if(U===g){const t=u(M),e=d(M),n=e-t;F=i(t,n,!0,l+1,c+M,B)}else F=U&&r(M,s,o,i,a,c,l+1);return!!F}}}(),Mt=function(){const t=new N,e=new N,n=new s.M,o=new Y,r=new Y;return function s(i,a,c,l,u=null){let d=2*i,f=St,p=Ut,h=Ft;null===u&&(c.boundingBox||c.computeBoundingBox(),o.set(c.boundingBox.min,c.boundingBox.max,l),u=o);const y=dt(d,p);if(!y){const t=i+8,e=h[i+6];T(mt(t),f,wt);const n=u.intersectsBox(wt)&&s(t,a,c,l,u);if(n)return!0;T(mt(e),f,wt);const o=u.intersectsBox(wt)&&s(e,a,c,l,u);return!!o}{const s=a,o=s.index,u=s.attributes.position,y=c.index,g=c.attributes.position,m=ft(i,h),w=pt(d,p);if(n.copy(l).invert(),c.boundsTree){T(mt(i),f,r),r.matrix.copy(n),r.needsUpdate=!0;const t=c.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.needsUpdate=!0;for(let n=3*m,s=3*(w+m);n<s;n+=3)if(ct(e,n,o,u),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}});return t}for(let r=3*m,i=w+3*m;r<i;r+=3){ct(t,r,o,u),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,s=y.count;n<s;n+=3)if(ct(e,n,y,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function At(t,e,n,s){return T(t,e,wt),n.intersectBox(wt,s)}const Vt=[];let vt,St,Ut,Ft;function zt(t){vt&&Vt.push(vt),vt=t,St=new Float32Array(t),Ut=new Uint16Array(t),Ft=new Uint32Array(t)}function It(){vt=null,St=null,Ut=null,Ft=null,Vt.length&&zt(Vt.pop())}const _t=Symbol("skip tree generation"),qt=new s.at,Ct=new s.at,Et=new s.M,Ot=new Y,kt=new Y,Ht=new s.V,Dt=new s.V,jt=new s.V,Gt=new s.V,Xt=new s.V,Lt=new s.at,Wt=new ut((()=>new N));class Rt{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Rt.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e=d({cloneBuffers:!0},e);const n=t.geometry,s=t._roots,o=n.getIndex();let r;return r=e.cloneBuffers?{roots:s.map((t=>t.slice())),index:o.array.slice()}:{roots:s,index:o.array},r}static deserialize(t,e,n={}){if("boolean"===typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Rt.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n=d({setIndex:!0},n);const{index:o,roots:r}=t,i=new Rt(e,f(d({},n),{[_t]:!0}));if(i._roots=r,n.setIndex){const n=e.getIndex();if(null===n){const n=new s.ak(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(e=Object.assign({strategy:p,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[_t]:!1},e),e.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[_t]||(this._roots=G(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new s.at))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,s=e.attributes.position,o=s.array,r=s.offset||0;let i,a,c,l,u=3;s.isInterleavedBufferAttribute&&(u=s.data.stride);let d=0;const f=this._roots;for(let h=0,y=f.length;h<y;h++)i=f[h],a=new Uint32Array(i),c=new Uint16Array(i),l=new Float32Array(i),p(0,d),d+=i.byteLength;function p(e,s,i=!1){const d=2*e,f=c[d+15]===b;if(f){const t=a[e+6],s=c[d+14];let i=1/0,f=1/0,p=1/0,h=-1/0,y=-1/0,g=-1/0;for(let e=3*t,a=3*(t+s);e<a;e++){const t=n[e]*u+r,s=o[t+0],a=o[t+1],c=o[t+2];s<i&&(i=s),s>h&&(h=s),a<f&&(f=a),a>y&&(y=a),c<p&&(p=c),c>g&&(g=c)}return(l[e+0]!==i||l[e+1]!==f||l[e+2]!==p||l[e+3]!==h||l[e+4]!==y||l[e+5]!==g)&&(l[e+0]=i,l[e+1]=f,l[e+2]=p,l[e+3]=h,l[e+4]=y,l[e+5]=g,!0)}{const n=e+8,o=a[e+6],r=n+s,c=o+s;let u=i,d=!1,f=!1;t?u||(d=t.has(r),f=t.has(c),u=!d&&!f):(d=!0,f=!0);const h=u||d,y=u||f;let g=!1;h&&(g=p(n,s,u));let m=!1;y&&(m=p(o,s,u));const w=g||m;if(w)for(let t=0;t<3;t++){const s=n+t,r=o+t,i=l[s],a=l[s+3],c=l[r],u=l[r+3];l[e+t]=i<c?i:c,l[e+t+3]=a>u?a:u}return w}}}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),o=new Uint16Array(n);function r(e,i=0){const a=2*e,c=o[a+15]===b;if(c){const r=s[e+6],l=o[a+14];t(i,c,new Float32Array(n,4*e,6),r,l)}else{const o=e+x/4,a=s[e+6],l=s[e+7],u=t(i,c,new Float32Array(n,4*e,6),l);u||(r(o,i+1),r(a,i+1))}}r(0)}raycast(t,e=s.as){const n=this._roots,o=this.geometry,r=[],i=e.isMaterial,a=Array.isArray(e),c=o.groups,l=i?e.side:e;for(let s=0,u=n.length;s<u;s++){const i=a?e[c[s].materialIndex].side:l,u=r.length;if(zt(n[s]),Bt(0,o,i,t,r),It(),a){const t=c[s].materialIndex;for(let e=u,n=r.length;e<n;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=s.as){const n=this._roots,o=this.geometry,r=e.isMaterial,i=Array.isArray(e);let a=null;const c=o.groups,l=r?e.side:e;for(let s=0,u=n.length;s<u;s++){const r=i?e[c[s].materialIndex].side:l;zt(n[s]);const u=Pt(0,o,r,t);It(),null!=u&&(null==a||u.distance<a.distance)&&(a=u,i&&(u.face.materialIndex=c[s].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let s=!1;for(const o of this._roots)if(zt(o),s=Mt(0,n,t,e),It(),s)break;return s}shapecast(t,e,n){const s=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,s,o)=>{const r=3*n;return t(e,r,r+1,r+2,s,o)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=Wt.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,n,r,i,a)=>!!t(e,n,r,i,a)||lt(e,n,s,c,r,i,o)}else a||(a=c?(t,e,n,r)=>lt(t,e,s,c,n,r,o):(t,e,n)=>n);let l=!1,u=0;for(const d of this._roots){if(zt(d),l=Tt(0,s,i,a,r,u),It(),l)break;u+=d.byteLength}return Wt.releasePrimitive(o),l}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:o}=n;const r=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;Et.copy(e).invert();const l=Wt.getPrimitive(),u=Wt.getPrimitive();if(o){let t=function(t,n,s,d,f,p,h,y){for(let g=s,m=s+d;g<m;g++){ct(u,3*g,a,c),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,s=t+n;e<s;e++)if(ct(l,3*e,r,i),l.needsUpdate=!0,o(l,u,e,g,f,p,h,y))return!0}return!1};if(s){const e=s;s=function(n,s,o,r,i,a,c,l){return!!e(n,s,o,r,i,a,c,l)||t(n,s,o,r,i,a,c,l)}}else s=t}this.getBoundingBox(Ct),Ct.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>Ct.intersectsBox(t),intersectsRange:(e,n,o,r,i,a)=>(qt.copy(a),qt.applyMatrix4(Et),t.shapecast({intersectsBounds:t=>qt.intersectsBox(t),intersectsRange:(t,o,a,c,l)=>s(e,n,t,o,r,i,c,l)}))});return Wt.releasePrimitive(l),Wt.releasePrimitive(u),d}intersectsBox(t,e){return Ot.set(t.min,t.max,e),Ot.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ot.intersectsBox(t),intersectsTriangle:t=>Ot.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Ot.set(t.boundingBox.min,t.boundingBox.max,e),Ot.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,l=t.attributes.position,u=t.index,d=Wt.getPrimitive(),f=Wt.getPrimitive();let p=Dt,h=jt,y=null,g=null;s&&(y=Gt,g=Xt);let m=1/0,w=null,x=null;return Et.copy(e).invert(),kt.matrix.copy(Et),this.shapecast({boundsTraverseOrder:t=>Ot.distanceToBox(t,Math.min(m,r)),intersectsBounds:(t,e,n)=>n<m&&n<r&&(e&&(kt.min.copy(t.min),kt.max.copy(t.max),kt.needsUpdate=!0),!0),intersectsRange:(n,s)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>kt.distanceToBox(t,Math.min(m,r)),intersectsBounds:(t,e,n)=>n<m&&n<r,intersectsRange:(t,r)=>{for(let i=3*t,b=3*(t+r);i<b;i+=3){ct(f,i,u,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+s);t<e;t+=3){ct(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(f,p,y);if(e<m&&(h.copy(p),g&&g.copy(y),m=e,w=t/3,x=i/3),e<o)return!0}}}});{const t=u?u.count:l.count;for(let r=0,i=t;r<i;r+=3){ct(f,r,u,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+s);t<e;t+=3){ct(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(f,p,y);if(e<m&&(h.copy(p),g&&g.copy(y),m=e,w=t/3,x=r/3),e<o)return!0}}}}}),Wt.releasePrimitive(d),Wt.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(h):n.point=h.clone(),n.distance=m,n.faceIndex=w,s&&(s.point?s.point.copy(g):s.point=g.clone(),s.point.applyMatrix4(Et),h.applyMatrix4(Et),s.distance=h.sub(s.point).length(),s.faceIndex=x),n)}closestPointToPoint(t,e={},n=0,s=1/0){const o=n*n,r=s*s;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(Ht.copy(t).clamp(e.min,e.max),Ht.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<i&&n<r,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,Ht);const s=t.distanceToSquared(Ht);return s<i&&(Dt.copy(Ht),i=s,a=n),s<o}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(Dt):e.point=Dt.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){t.makeEmpty();const e=this._roots;return e.forEach((e=>{T(0,new Float32Array(e),Lt),t.union(Lt)})),t}}const Nt=Rt.prototype.raycast;Rt.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,s,o]=t,r=Nt.call(this,s,e.material);return r.forEach((t=>{t=at(t,e,n),t&&o.push(t)})),o}return Nt.apply(this,t)};const Yt=Rt.prototype.raycastFirst;Rt.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,s]=t;return at(Yt.call(this,s,e.material),e,n)}return Yt.apply(this,t)};const Zt=Rt.prototype.closestPointToPoint;Rt.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,Zt.apply(this,t),e&&e.copy(n.point),n.distance}return Zt.apply(this,t)};const $t=Rt.prototype.closestPointToGeometry;Rt.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const s={},o={},r=t[1];return t[2]=s,t[3]=o,$t.apply(this,t),e&&e.copy(s.point),n&&n.copy(o.point).applyMatrix4(r),s.distance}return $t.apply(this,t)};const Jt=Rt.prototype.refit;Rt.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),Jt.call(this,t)}else Jt.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=Rt.prototype[t];Rt.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}}));const Kt=new s.at;class Qt extends s.O{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,o=0){super(),this.material=e,this.geometry=new s.b,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=o}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const o=this.depth-1,r=this.displayParents;let i=0;e.traverse(((t,e)=>{if(t===o||e)return i++,!0;r&&i++}),n);let a=0;const c=new Float32Array(24*i);let l,u;e.traverse(((t,e,n)=>{const s=t===o||e;if(s||r){T(0,n,Kt);const{min:t,max:e}=Kt;for(let n=-1;n<=1;n+=2){const s=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const o=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const r=n<0?t.z:e.z;c[a+0]=s,c[a+1]=o,c[a+2]=r,a+=3}}}return s}}),n),u=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),l=c.length>65535?new Uint32Array(u.length*i):new Uint16Array(u.length*i);const d=u.length;for(let t=0;t<i;t++){const e=8*t,n=t*d;for(let t=0;t<d;t++)l[n+t]=e+u[t]}t.setIndex(new s.ak(l,1,!1)),t.setAttribute("position",new s.ak(c,3,!1)),this.visible=!0}}}class te extends s.G{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new s.L({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),o=new s.a({color:65416,transparent:!0,opacity:.3,depthWrite:!1});o.color=n.color,this.edgeMaterial=n,this.meshMaterial=o,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;while(this._roots.length>e)this._roots.pop();for(let n=0;n<e;n++){if(n>=this._roots.length){const t=new Qt(this.mesh,this.edgeMaterial,this.depth,n);this.add(t),this._roots.push(t)}const t=this._roots[n];t.depth=this.depth,t.mesh=this.mesh,t.displayParents=this.displayParents,t.displayEdges=this.displayEdges,t.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,t.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new te(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}s.c.prototype.raycast;const ee=new WeakMap;var ne=t=>{t.outerObject3d.updateMatrixWorld(!0);const e=[];t.outerObject3d.traverse((n=>{if(!n.geometry||n===(0,s.aX)(t)&&!(t instanceof s.aY))return;const o=n.geometry.clone();o.applyMatrix4(n.matrixWorld),e.push(o),o.dispose()}));const n=[];for(const s of e){const e=s.boundsTree=new Rt(s);n.push(e),ee.set(e,t)}return[n,e]}}}]);
//# sourceMappingURL=127.4e156241.js.map