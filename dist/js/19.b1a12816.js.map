{"version":3,"file":"js/19.b1a12816.js","mappings":"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","sources":["webpack://vue3/./node_modules/lingo3d-vue/dist/loadGLTF.js"],"sourcesContent":["import { h as Loader, i as LoaderUtils, j as FileLoader, q as Color, z as SpotLight, x as PointLight, A as DirectionalLight, a as MeshBasicMaterial, s as sRGBEncoding, a3 as MeshPhysicalMaterial, a4 as Vector2, a5 as MeshStandardMaterial, a6 as TangentSpaceNormalMap, a7 as Interpolant, Q as Quaternion, a8 as NearestFilter, a9 as LinearFilter, aa as NearestMipmapNearestFilter, ab as LinearMipmapNearestFilter, ac as NearestMipmapLinearFilter, ad as LinearMipmapLinearFilter, m as ClampToEdgeWrapping, ae as MirroredRepeatWrapping, l as RepeatWrapping, af as InterpolateLinear, ag as InterpolateDiscrete, k as TextureLoader, ah as ImageBitmapLoader, ai as InterleavedBuffer, aj as InterleavedBufferAttribute, ak as BufferAttribute, al as PointsMaterial, am as Material, L as LineBasicMaterial, D as DoubleSide, u as PropertyBinding, b as BufferGeometry, H as SkinnedMesh, c as Mesh, an as TriangleStripDrawMode, ao as TriangleFanDrawMode, ap as LineSegments, e as Line, aq as LineLoop, ar as Points, G as Group, w as PerspectiveCamera, y as MathUtils, v as OrthographicCamera, W as VectorKeyframeTrack, X as QuaternionKeyframeTrack, Y as NumberKeyframeTrack, N as AnimationClip, t as Bone, O as Object3D, M as Matrix4, I as Skeleton, as as FrontSide, n as Texture, at as Box3, V as Vector3, au as Sphere, Z as forceGet, _ as cloneSkinnedMesh, av as getWasmPath, $ as increaseLoadingCount, a0 as decreaseLoadingCount, a1 as LinearEncoding, a2 as handleProgress } from \"./index.js\";\nimport \"vue\";\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader2 = new FileLoader(this.manager);\n    loader2.setPath(this.path);\n    loader2.setResponseType(\"arraybuffer\");\n    loader2.setRequestHeader(this.requestHeader);\n    loader2.setWithCredentials(this.withCredentials);\n    loader2.load(url, function(data) {\n      try {\n        scope.parse(data, resourcePath, function(gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n  setDRACOLoader(dracoLoader2) {\n    this.dracoLoader = dracoLoader2;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      content = data;\n    } else {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n    const json = JSON.parse(content);\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: \"KHR_materials_pbrSpecularGlossiness\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0)\n      color.fromArray(lightDef.color);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, sRGBEncoding));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, sRGBEncoding));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || 0;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, sRGBEncoding));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader2 = parser.options.ktx2Loader;\n    if (!loader2) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader2);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader2 = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader2 = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader2);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return Promise.all([buffer, decoder.ready]).then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const result = new ArrayBuffer(count * stride);\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\n        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n        return result;\n      });\n    } else {\n      return null;\n    }\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader2) {\n    if (!dracoLoader2) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader2;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader2 = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve) {\n        dracoLoader2.decodeDracoFile(bufferView, function(geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== void 0)\n              attribute.normalized = normalized;\n          }\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if (transform.texCoord !== void 0) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n    if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n  constructor(params) {\n    super();\n    this.isGLTFSpecularGlossinessMaterial = true;\n    const specularMapParsFragmentChunk = [\n      \"#ifdef USE_SPECULARMAP\",\n      \"\tuniform sampler2D specularMap;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const glossinessMapParsFragmentChunk = [\n      \"#ifdef USE_GLOSSINESSMAP\",\n      \"\tuniform sampler2D glossinessMap;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const specularMapFragmentChunk = [\n      \"vec3 specularFactor = specular;\",\n      \"#ifdef USE_SPECULARMAP\",\n      \"\tvec4 texelSpecular = texture2D( specularMap, vUv );\",\n      \"\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\",\n      \"\tspecularFactor *= texelSpecular.rgb;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const glossinessMapFragmentChunk = [\n      \"float glossinessFactor = glossiness;\",\n      \"#ifdef USE_GLOSSINESSMAP\",\n      \"\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );\",\n      \"\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\",\n      \"\tglossinessFactor *= texelGlossiness.a;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const lightPhysicalFragmentChunk = [\n      \"PhysicalMaterial material;\",\n      \"material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\",\n      \"vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\",\n      \"float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\",\n      \"material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\",\n      \"material.roughness += geometryRoughness;\",\n      \"material.roughness = min( material.roughness, 1.0 );\",\n      \"material.specularColor = specularFactor;\"\n    ].join(\"\\n\");\n    const uniforms = {\n      specular: { value: new Color().setHex(16777215) },\n      glossiness: { value: 1 },\n      specularMap: { value: null },\n      glossinessMap: { value: null }\n    };\n    this._extraUniforms = uniforms;\n    this.onBeforeCompile = function(shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n      shader.fragmentShader = shader.fragmentShader.replace(\"uniform float roughness;\", \"uniform vec3 specular;\").replace(\"uniform float metalness;\", \"uniform float glossiness;\").replace(\"#include <roughnessmap_pars_fragment>\", specularMapParsFragmentChunk).replace(\"#include <metalnessmap_pars_fragment>\", glossinessMapParsFragmentChunk).replace(\"#include <roughnessmap_fragment>\", specularMapFragmentChunk).replace(\"#include <metalnessmap_fragment>\", glossinessMapFragmentChunk).replace(\"#include <lights_physical_fragment>\", lightPhysicalFragmentChunk);\n    };\n    Object.defineProperties(this, {\n      specular: {\n        get: function() {\n          return uniforms.specular.value;\n        },\n        set: function(v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function() {\n          return uniforms.specularMap.value;\n        },\n        set: function(v) {\n          uniforms.specularMap.value = v;\n          if (v) {\n            this.defines.USE_SPECULARMAP = \"\";\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function() {\n          return uniforms.glossiness.value;\n        },\n        set: function(v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function() {\n          return uniforms.glossinessMap.value;\n        },\n        set: function(v) {\n          uniforms.glossinessMap.value = v;\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = \"\";\n            this.defines.USE_UV = \"\";\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n  copy(source) {\n    super.copy(source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n}\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = [\n      \"color\",\n      \"map\",\n      \"lightMap\",\n      \"lightMapIntensity\",\n      \"aoMap\",\n      \"aoMapIntensity\",\n      \"emissive\",\n      \"emissiveIntensity\",\n      \"emissiveMap\",\n      \"bumpMap\",\n      \"bumpScale\",\n      \"normalMap\",\n      \"normalMapType\",\n      \"displacementMap\",\n      \"displacementScale\",\n      \"displacementBias\",\n      \"specularMap\",\n      \"specular\",\n      \"glossinessMap\",\n      \"glossiness\",\n      \"alphaMap\",\n      \"envMap\",\n      \"envMapIntensity\"\n    ];\n  }\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const pending = [];\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"map\", pbrSpecularGlossiness.diffuseTexture, sRGBEncoding));\n    }\n    materialParams.emissive = new Color(0, 0, 0);\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;\n    materialParams.specular = new Color(1, 1, 1);\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(parser.assignTexture(materialParams, \"glossinessMap\", specGlossMapDef));\n      pending.push(parser.assignTexture(materialParams, \"specularMap\", specGlossMapDef, sRGBEncoding));\n    }\n    return Promise.all(pending);\n  }\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n    material.color = materialParams.color;\n    material.map = materialParams.map === void 0 ? null : materialParams.map;\n    material.lightMap = null;\n    material.lightMapIntensity = 1;\n    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1;\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = materialParams.emissiveIntensity === void 0 ? 1 : materialParams.emissiveIntensity;\n    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;\n    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;\n    material.normalMapType = TangentSpaceNormalMap;\n    if (materialParams.normalScale)\n      material.normalScale = materialParams.normalScale;\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;\n    material.specular = materialParams.specular;\n    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n    material.alphaMap = null;\n    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;\n    material.envMapIntensity = 1;\n    return material;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n}\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {\n  const result = this.resultBuffer;\n  const values = this.sampleValues;\n  const stride = this.valueSize;\n  const stride2 = stride * 2;\n  const stride3 = stride * 3;\n  const td = t1 - t0;\n  const p = (t - t0) / td;\n  const pp = p * p;\n  const ppp = pp * p;\n  const offset1 = i1 * stride3;\n  const offset0 = offset1 - stride3;\n  const s2 = -2 * ppp + 3 * pp;\n  const s3 = ppp - pp;\n  const s0 = 1 - s2;\n  const s1 = s3 - pp + p;\n  for (let i = 0; i !== stride; i++) {\n    const p0 = values[offset0 + i + stride];\n    const m0 = values[offset0 + i + stride2] * td;\n    const p1 = values[offset1 + i + stride];\n    const m1 = values[offset1 + i] * td;\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n  return result;\n};\nconst _q = new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  \"SCALAR\": 1,\n  \"VEC2\": 2,\n  \"VEC3\": 3,\n  \"VEC4\": 4,\n  \"MAT2\": 4,\n  \"MAT3\": 9,\n  \"MAT4\": 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  TEXCOORD_0: \"uv\",\n  TEXCOORD_1: \"uv2\",\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache2) {\n  if (cache2[\"DefaultMaterial\"] === void 0) {\n    cache2[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache2[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n    const isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n    const firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(this._invokeAll(function(ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(parser._invokeAll(function(ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function() {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  _addNodeRef(cache2, index) {\n    if (index === void 0)\n      return;\n    if (cache2.refs[index] === void 0) {\n      cache2.refs[index] = cache2.uses[index] = 0;\n    }\n    cache2.refs[index]++;\n  }\n  _getNodeRef(cache2, index, object) {\n    if (cache2.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache2.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this.loadNode(index);\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          throw new Error(\"Unknown type: \" + type);\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(defs.map(function(def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader2 = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader2.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      return Promise.resolve(null);\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader2 = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader2 = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader2);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader2) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader2).then(function(texture) {\n      texture.flipY = false;\n      if (textureDef.name)\n        texture.name = textureDef.name;\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader2) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL2 = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL2.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader2.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader2.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL2.revokeObjectURL(sourceURI);\n      }\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === \"aoMap\" && mapDef.texCoord == 1)) {\n        console.warn(\"THREE.GLTFLoader: Custom UV set \" + mapDef.texCoord + \" for texture \" + mapName + \" not yet supported.\");\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (encoding !== void 0) {\n        texture.encoding = encoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (material.isGLTFSpecularGlossinessMaterial)\n        cacheKey += \"specular-glossiness:\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {\n      geometry.setAttribute(\"uv2\", geometry.attributes.uv);\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, sRGBEncoding));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function(ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, sRGBEncoding));\n    }\n    return Promise.all(pending).then(function() {\n      let material;\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    let name = sanitizedName;\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + \"_\" + i;\n    }\n    this.nodeNamesUsed[name] = true;\n    return name;\n  }\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache2 = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache2[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache2[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n      const group = new Group();\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const skinEntry = { joints: skinDef.joints };\n    if (skinDef.inverseBindMatrices === void 0) {\n      return Promise.resolve(skinEntry);\n    }\n    return this.getDependency(\"accessor\", skinDef.inverseBindMatrices).then(function(accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  }\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node !== void 0 ? target.node : target.id;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        let TypedKeyframeTrack;\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function(object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n        let outputArray = outputAccessor.array;\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n          outputArray = scaled;\n        }\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n          if (sampler.interpolation === \"CUBICSPLINE\") {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n            };\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n          tracks.push(track);\n        }\n      }\n      const name = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n      return new AnimationClip(name, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    return function() {\n      const pending = [];\n      const meshPromise = parser._invokeOne(function(ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n      if (nodeDef.camera !== void 0) {\n        pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        }));\n      }\n      parser._invokeAll(function(ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n      }).forEach(function(promise) {\n        pending.push(promise);\n      });\n      return Promise.all(pending);\n    }().then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n  }\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));\n    }\n    return Promise.all(pending).then(function() {\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n}\nfunction buildNodeHierarchy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n  return parser.getDependency(\"node\", nodeId).then(function(node) {\n    if (nodeDef.skin === void 0)\n      return node;\n    let skinEntry;\n    return parser.getDependency(\"skin\", nodeDef.skin).then(function(skin) {\n      skinEntry = skin;\n      const pendingJoints = [];\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency(\"node\", skinEntry.joints[i]));\n      }\n      return Promise.all(pendingJoints);\n    }).then(function(jointNodes) {\n      node.traverse(function(mesh) {\n        if (!mesh.isMesh)\n          return;\n        const bones = [];\n        const boneInverses = [];\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n          const jointNode = jointNodes[j];\n          if (jointNode) {\n            bones.push(jointNode);\n            const mat = new Matrix4();\n            if (skinEntry.inverseBindMatrices !== void 0) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function(node) {\n    parentObject.add(node);\n    const pending = [];\n    if (nodeDef.children) {\n      const children = nodeDef.children;\n      for (let i = 0, il = children.length; i < il; i++) {\n        const child = children[i];\n        pending.push(buildNodeHierarchy(child, node, json, parser));\n      }\n    }\n    return Promise.all(pending);\n  });\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex();\n  if (index === null) {\n    const indices = [];\n    const position = geometry.getAttribute(\"position\");\n    if (position !== void 0) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n      return geometry;\n    }\n  }\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n  if (drawMode === TriangleFanDrawMode) {\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n  }\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader2 = new FileLoader(this.manager);\n    loader2.setPath(this.path);\n    loader2.setResponseType(\"arraybuffer\");\n    loader2.setRequestHeader(this.requestHeader);\n    loader2.setWithCredentials(this.withCredentials);\n    loader2.load(url, (buffer) => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader2 = new FileLoader(this.manager);\n    loader2.setPath(this.decoderPath);\n    loader2.setResponseType(responseType);\n    loader2.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader2.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map((worker) => worker._taskLoad));\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nconst cache = /* @__PURE__ */ new Map();\nconst loader = new GLTFLoader();\nconst dracoLoader = new DRACOLoader();\ngetWasmPath((wasmPath) => dracoLoader.setDecoderPath(wasmPath));\nloader.setDRACOLoader(dracoLoader);\nvar loadGLTF = async (url, clone) => {\n  const [gltf, noBone] = await forceGet(cache, url, () => new Promise((resolve, reject) => {\n    increaseLoadingCount();\n    loader.load(url, (gltf2) => {\n      decreaseLoadingCount();\n      let noBone2 = true;\n      for (const scene of gltf2.scenes)\n        scene.traverse((child) => {\n          var _a;\n          noBone2 && child instanceof Bone && (noBone2 = false);\n          ((_a = child.material) == null ? void 0 : _a.map) && (child.material.map.encoding = LinearEncoding);\n        });\n      resolve([gltf2, noBone2]);\n    }, handleProgress, () => {\n      decreaseLoadingCount();\n      reject();\n    });\n  }));\n  if (clone)\n    return cloneSkinnedMesh(gltf.scene, noBone, gltf.animations);\n  return gltf.scene;\n};\nexport { loadGLTF as default };\n"],"names":["GLTFLoader","Loader","constructor","manager","super","this","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFLightsExtension","GLTFMeshoptCompression","load","url","onLoad","onProgress","onError","scope","resourcePath","path","LoaderUtils","itemStart","_onError","e","console","error","itemError","itemEnd","loader2","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","gltf","setDRACOLoader","dracoLoader2","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","indexOf","push","unregister","splice","content","extensions","plugins","magic","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","asset","version","GLTFParser","crossOrigin","fileLoader","i","length","plugin","name","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","warn","setExtensions","setPlugins","parseAsync","Promise","resolve","reject","GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_MESHOPT_COMPRESSION","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDefs","lights","lightDef","lightNode","color","Color","fromArray","range","type","DirectionalLight","target","position","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","createUniqueName","createNodeAttachment","self2","then","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","sRGBEncoding","all","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","index","bufferView","bufferViews","extensionDef","buffer","getDependency","decoder","supported","ready","res","byteOffset","byteLength","count","stride","byteStride","result","ArrayBuffer","decodeGltfBuffer","mode","filter","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","primitive","bufferViewIndex","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","geometry","attribute","extendTexture","texture","transform","texCoord","offset","rotation","clone","repeat","needsUpdate","GLTFMeshStandardSGMaterial","MeshStandardMaterial","params","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","uniforms","specular","value","setHex","glossiness","specularMap","glossinessMap","_extraUniforms","onBeforeCompile","shader","uniformName","fragmentShader","replace","Object","defineProperties","v","defines","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","metalness","roughness","metalnessMap","roughnessMap","setValues","copy","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","material","fog","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","prototype","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","Quaternion","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","WEBGL_CONSTANTS","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","createDefaultMaterial","cache2","transparent","depthTest","side","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","assign","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","il","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphColors","morphAttributes","morphTargetsRelative","updateMorphTargets","mesh","meshDef","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","geometryKey","indices","createAttributesKey","attributesKey","keys","sort","getNormalizedComponentScale","getImageURIMimeType","search","associations","Map","primitiveCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","test","navigator","userAgent","isFirefox","firefoxVersion","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","meshes","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","updateMappings","original","mappings","child","children","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","bufferViewDef","accessorIndex","sparse","pendingBufferViews","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","BufferAttribute","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","samplers","magFilter","minFilter","wrapS","wrapT","URL2","self","URL","webkitURL","sourceURI","isObjectURL","blob","Blob","mimeType","createObjectURL","sourceURI2","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","mapName","mapDef","encoding","gltfReference","assignFinalMaterial","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","y","uv2","uv","setAttribute","materialType","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","DoubleSide","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","originalName","sanitizedName","PropertyBinding","loadGeometries","primitives","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","results","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","cameraDef","PerspectiveCamera","MathUtils","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","updateMatrix","matrixAutoUpdate","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","outputArray","scaled","j","jl","track","createInterpolant","interpolantType","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","createNodeMesh","o","isMesh","nodeName","meshPromise","forEach","Bone","Object3D","matrix","Matrix4","applyMatrix4","quaternion","has","sceneIndex","sceneDef","nodeIds","buildNodeHierarchy","reduceAssociations","reducedAssociations","node2","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","computeBounds","box","Box3","min","max","Vector3","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","assignAttributeAccessor","gltfAttributeName","accessor2","setIndex","drawMode","getIndex","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","_taskCache","WeakMap","DRACOLoader","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","defaultAttributeTypes","setDecoderPath","setDecoderConfig","config","setWorkerLimit","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","taskKey","stringify","cachedTask","worker","taskID","taskCost","geometryPending","_getWorker","_worker","_callbacks","postMessage","message","_createGeometry","_releaseTask","geometryData","_loadLibrary","responseType","_initDecoder","useJS","WebAssembly","librariesPending","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","substring","lastIndexOf","worker2","Worker","_taskCosts","_taskLoad","onmessage","a","b","debug","log","dispose","terminate","draco","decoderBuffer","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","destroy","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","DT_FLOAT32","DT_INT8","DT_INT16","Int32Array","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","onModuleLoaded","DracoDecoderModule","module","Decoder","DecoderBuffer","Init","attr","loader","getWasmPath","wasmPath","loadGLTF","async","noBone","forceGet","increaseLoadingCount","gltf2","decreaseLoadingCount","noBone2","_a","LinearEncoding","handleProgress","cloneSkinnedMesh"],"sourceRoot":""}