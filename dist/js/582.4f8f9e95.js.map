{"version":3,"file":"js/582.4f8f9e95.js","mappings":"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","sources":["webpack://vue3/./node_modules/lingo3d-vue/dist/loadSVG.js"],"sourcesContent":["import { h as Loader, j as FileLoader, K as Matrix3, a4 as Vector2, V as Vector3, aw as ShapeUtils, ax as Box2, ay as Shape, az as Path, b as BufferGeometry, F as Float32BufferAttribute, aA as ShapePath, Z as forceGet, $ as increaseLoadingCount, a0 as decreaseLoadingCount, a2 as handleProgress } from \"./index.js\";\nimport \"vue\";\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.defaultDPI = 90;\n    this.defaultUnit = \"px\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader2 = new FileLoader(scope.manager);\n    loader2.setPath(scope.path);\n    loader2.setRequestHeader(scope.requestHeader);\n    loader2.setWithCredentials(scope.withCredentials);\n    loader2.load(url, function(text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1)\n        return;\n      const transform = getNodeTransform(node);\n      let isDefsNode = false;\n      let path = null;\n      switch (node.nodeName) {\n        case \"svg\":\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\"))\n            path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          isDefsNode = true;\n          break;\n        case \"use\":\n          style = parseStyle(node, style);\n          const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n          const usedNodeId = href.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n      }\n      if (path) {\n        if (style.fill !== void 0 && style.fill !== \"none\") {\n          path.color.setStyle(style.fill);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = { node, style };\n      }\n      const childNodes = node.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const node2 = childNodes[i];\n        if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n          continue;\n        }\n        parseNode(node2, style);\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      const commands = d.match(/[a-df-z][^a-df-z]*/ig);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data2 = command.slice(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n        return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1)\n          continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n        }\n      }\n    }\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n      const dx2 = (start.x - end.x) / 2;\n      const dy2 = (start.y - end.y) / 2;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag)\n        q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n      if (ux * vy - uy * vx < 0)\n        ang = -ang;\n      return ang;\n    }\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath();\n      path.moveTo(x + rx, y);\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseStyle(node, style) {\n      style = Object.assign({}, style);\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === void 0)\n          adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\"))\n              console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n        if (node.hasAttribute(svgName))\n          style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName])\n          style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\")\n          style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"fill-rule\", \"fillRule\");\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\", exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current2, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\")\n            result.push(Number(number));\n          else\n            result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n        if (state === SEP) {\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n      newNumber();\n      return result;\n    }\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n    const unitConversion = {\n      \"mm\": {\n        \"mm\": 1,\n        \"cm\": 0.1,\n        \"in\": 1 / 25.4,\n        \"pt\": 72 / 25.4,\n        \"pc\": 6 / 25.4,\n        \"px\": -1\n      },\n      \"cm\": {\n        \"mm\": 10,\n        \"cm\": 1,\n        \"in\": 1 / 2.54,\n        \"pt\": 72 / 2.54,\n        \"pc\": 6 / 2.54,\n        \"px\": -1\n      },\n      \"in\": {\n        \"mm\": 25.4,\n        \"cm\": 2.54,\n        \"in\": 1,\n        \"pt\": 72,\n        \"pc\": 6,\n        \"px\": -1\n      },\n      \"pt\": {\n        \"mm\": 25.4 / 72,\n        \"cm\": 2.54 / 72,\n        \"in\": 1 / 72,\n        \"pt\": 1,\n        \"pc\": 6 / 72,\n        \"px\": -1\n      },\n      \"pc\": {\n        \"mm\": 25.4 / 6,\n        \"cm\": 2.54 / 6,\n        \"in\": 1 / 6,\n        \"pt\": 72 / 6,\n        \"pc\": 1,\n        \"px\": -1\n      },\n      \"px\": {\n        \"px\": 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = void 0;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform2 = tempTransform0;\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\")\n            continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos);\n            const array = parseFloats(transformText.slice(openParPos + 1));\n            currentTransform2.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform2.translate(tx, ty);\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n                  angle = -array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    cx = array[1];\n                    cy = array[2];\n                  }\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform2.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform2);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      const isRotated = isTransformRotated(m);\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n            }\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n    parseNode(xml.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    });\n    const data = { paths, xml: xml.documentElement };\n    return data;\n  }\n  static createShapes(shapePath) {\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return { x, y, t: classifyResult.t };\n          }\n        }\n        return null;\n      } else {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return { x, y, t: t1 };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find((i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach((path) => {\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n      if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach((i2) => {\n        if (i2.identifier === simplePath.identifier) {\n          baseIntersections.push(i2);\n        } else {\n          otherIntersections.push(i2);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else if (_fillRule === \"nonzero\") {\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i2 = 0; i2 < stack.length; i2++) {\n          const identifier2 = stack[i2];\n          if (isHole) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = false;\n            isHoleFor = identifier2;\n          } else if (lastCWValue !== allPaths[identifier2].isCW) {\n            lastCWValue = allPaths[identifier2].isCW;\n            isHole = true;\n          }\n        }\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n      for (let i = 0; i < points.length; i++) {\n        const p2 = points[i];\n        if (p2.y > maxY) {\n          maxY = p2.y;\n        }\n        if (p2.y < minY) {\n          minY = p2.y;\n        }\n        if (p2.x > maxX) {\n          maxX = p2.x;\n        }\n        if (p2.x < minX) {\n          minX = p2.x;\n        }\n      }\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return { curves: p.curves, points, isCW: ShapeUtils.isClockWise(points), identifier: identifier++, boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)) };\n    });\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n    const isAHole = simplePaths.map((p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));\n    const shapesToReturn = [];\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    width = width !== void 0 ? width : 1;\n    color = color !== void 0 ? color : \"#000\";\n    lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n    lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n    miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n    minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2)\n      return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0, u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          nextPoint = points[1];\n        } else\n          nextPoint = void 0;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== void 0) {\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1)\n          initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n        if (dot !== 0) {\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                if (innerSideModified) {\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n      } else {\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1)\n        angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        if (joinIsOnLeftSide2) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points2) {\n      let dupPoints = false;\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints)\n        return points2;\n      const newPoints = [];\n      newPoints.push(points2[0]);\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n          newPoints.push(points2[i]);\n        }\n      }\n      newPoints.push(points2[points2.length - 1]);\n      return newPoints;\n    }\n  }\n}\nconst cache = /* @__PURE__ */ new Map();\nconst loader = new SVGLoader();\nvar loadSVG = (url) => forceGet(cache, url, () => new Promise((resolve, reject) => {\n  increaseLoadingCount();\n  loader.load(url, (svg) => {\n    decreaseLoadingCount();\n    resolve(Object.freeze(svg));\n  }, handleProgress, () => {\n    decreaseLoadingCount();\n    reject();\n  });\n}));\nexport { loadSVG as default };\n"],"names":["SVGLoader","Loader","constructor","manager","super","this","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader2","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","isDefsNode","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","href","getAttributeNS","usedNodeId","substring","usedNode","viewportElement","getElementById","warn","fill","color","setStyle","transformPath","currentTransform","paths","push","userData","childNodes","i","length","node2","transformStack","pop","copy","identity","ShapePath","point","Vector2","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data2","slice","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","i2","definitions","Object","fromEntries","entries","v","stylesheets","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","Path","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current2","partial","SyntaxError","newNumber","Number","pow","current","Array","isArray","includes","test","units","unitConversion","string","scale","theUnit","String","n","u","endsWith","parseFloat","parseNodeTransform","premultiply","Matrix3","currentTransform2","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","Vector3","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","data","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","isHoleTo","simplePath","allPaths","scanlineMinX2","scanlineMaxX2","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","identifier2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","p2","ShapeUtils","Box2","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","Shape","holes","hole","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","nextPoint","previousPoint","strokeWidth2","deltaU","u1","innerSideModified","joinIsOnLeftSide","isMiter","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","position","il","rotateAround","joinIsOnLeftSide2","innerSideModified2","addVectors","vl","points2","dupPoints","distanceTo","newPoints","cache","Map","loader","loadSVG","forceGet","Promise","resolve","reject","increaseLoadingCount","svg","decreaseLoadingCount","freeze","handleProgress"],"sourceRoot":""}