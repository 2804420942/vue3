{"version":3,"file":"js/127.4e156241.js","mappings":"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","sources":["webpack://vue3/./node_modules/lingo3d-vue/dist/computeBVH.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nimport { V as Vector3, a4 as Vector2, aT as Plane, aU as Line3, at as Box3, M as Matrix4, ak as BufferAttribute, as as FrontSide, G as Group, L as LineBasicMaterial, a as MeshBasicMaterial, c as Mesh, aV as Triangle, au as Sphere, O as Object3D, b as BufferGeometry, aW as BackSide, D as DoubleSide, aX as getObject3d, aY as Primitive } from \"./index.js\";\nconst CENTER = 0;\nconst AVERAGE = 1;\nconst SAH = 2;\nconst CONTAINED = 2;\nconst TRIANGLE_INTERSECT_COST = 1.25;\nconst TRAVERSAL_COST = 1;\nconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\nconst IS_LEAFNODE_FLAG = 65535;\nconst FLOAT32_EPSILON = Math.pow(2, -24);\nclass MeshBVHNode {\n  constructor() {\n  }\n}\nfunction arrayToBox(nodeIndex32, array, target) {\n  target.min.x = array[nodeIndex32];\n  target.min.y = array[nodeIndex32 + 1];\n  target.min.z = array[nodeIndex32 + 2];\n  target.max.x = array[nodeIndex32 + 3];\n  target.max.y = array[nodeIndex32 + 4];\n  target.max.z = array[nodeIndex32 + 5];\n  return target;\n}\nfunction getLongestEdgeIndex(bounds) {\n  let splitDimIdx = -1;\n  let splitDist = -Infinity;\n  for (let i = 0; i < 3; i++) {\n    const dist = bounds[i + 3] - bounds[i];\n    if (dist > splitDist) {\n      splitDist = dist;\n      splitDimIdx = i;\n    }\n  }\n  return splitDimIdx;\n}\nfunction copyBounds(source, target) {\n  target.set(source);\n}\nfunction unionBounds(a, b, target) {\n  let aVal, bVal;\n  for (let d = 0; d < 3; d++) {\n    const d3 = d + 3;\n    aVal = a[d];\n    bVal = b[d];\n    target[d] = aVal < bVal ? aVal : bVal;\n    aVal = a[d3];\n    bVal = b[d3];\n    target[d3] = aVal > bVal ? aVal : bVal;\n  }\n}\nfunction expandByTriangleBounds(startIndex, triangleBounds, bounds) {\n  for (let d = 0; d < 3; d++) {\n    const tCenter = triangleBounds[startIndex + 2 * d];\n    const tHalf = triangleBounds[startIndex + 2 * d + 1];\n    const tMin = tCenter - tHalf;\n    const tMax = tCenter + tHalf;\n    if (tMin < bounds[d]) {\n      bounds[d] = tMin;\n    }\n    if (tMax > bounds[d + 3]) {\n      bounds[d + 3] = tMax;\n    }\n  }\n}\nfunction computeSurfaceArea(bounds) {\n  const d0 = bounds[3] - bounds[0];\n  const d1 = bounds[4] - bounds[1];\n  const d2 = bounds[5] - bounds[2];\n  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\nfunction ensureIndex(geo, options) {\n  if (!geo.index) {\n    const vertexCount = geo.attributes.position.count;\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    let index;\n    if (vertexCount > 65535) {\n      index = new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n      index = new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (let i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{ offset: 0, count: geo.index.count / 3 }];\n  }\n  const ranges = [];\n  const rangeBoundaries = /* @__PURE__ */ new Set();\n  for (const group of geo.groups) {\n    rangeBoundaries.add(group.start);\n    rangeBoundaries.add(group.start + group.count);\n  }\n  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);\n  for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n    const start = sortedBoundaries[i], end = sortedBoundaries[i + 1];\n    ranges.push({ offset: start / 3, count: (end - start) / 3 });\n  }\n  return ranges;\n}\nfunction getBounds(triangleBounds, offset, count, target, centroidTarget = null) {\n  let minx = Infinity;\n  let miny = Infinity;\n  let minz = Infinity;\n  let maxx = -Infinity;\n  let maxy = -Infinity;\n  let maxz = -Infinity;\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  const includeCentroid = centroidTarget !== null;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    const hx = triangleBounds[i + 1];\n    const lx = cx - hx;\n    const rx = cx + hx;\n    if (lx < minx)\n      minx = lx;\n    if (rx > maxx)\n      maxx = rx;\n    if (includeCentroid && cx < cminx)\n      cminx = cx;\n    if (includeCentroid && cx > cmaxx)\n      cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    const hy = triangleBounds[i + 3];\n    const ly = cy - hy;\n    const ry = cy + hy;\n    if (ly < miny)\n      miny = ly;\n    if (ry > maxy)\n      maxy = ry;\n    if (includeCentroid && cy < cminy)\n      cminy = cy;\n    if (includeCentroid && cy > cmaxy)\n      cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    const hz = triangleBounds[i + 5];\n    const lz = cz - hz;\n    const rz = cz + hz;\n    if (lz < minz)\n      minz = lz;\n    if (rz > maxz)\n      maxz = rz;\n    if (includeCentroid && cz < cminz)\n      cminz = cz;\n    if (includeCentroid && cz > cmaxz)\n      cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    if (cx < cminx)\n      cminx = cx;\n    if (cx > cmaxx)\n      cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    if (cy < cminy)\n      cminy = cy;\n    if (cy > cmaxy)\n      cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    if (cz < cminz)\n      cminz = cz;\n    if (cz > cmaxz)\n      cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\nfunction partition(index, triangleBounds, offset, count, split) {\n  let left = offset;\n  let right = offset + count - 1;\n  const pos = split.pos;\n  const axisOffset = split.axis * 2;\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    }\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n    if (left < right) {\n      for (let i = 0; i < 3; i++) {\n        let t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        let t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        let t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\nconst BIN_COUNT = 32;\nconst binsSort = (a, b) => a.candidate - b.candidate;\nconst sahBins = new Array(BIN_COUNT).fill().map(() => {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nconst leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  let axis = -1;\n  let pos = 0;\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    let bestCost = TRIANGLE_INTERSECT_COST * count;\n    const cStart = offset * 6;\n    const cEnd = (offset + count) * 6;\n    for (let a = 0; a < 3; a++) {\n      const axisLeft = centroidBoundingData[a];\n      const axisRight = centroidBoundingData[a + 3];\n      const axisLength = axisRight - axisLeft;\n      const binWidth = axisLength / BIN_COUNT;\n      if (count < BIN_COUNT / 4) {\n        const truncatedBins = [...sahBins];\n        truncatedBins.length = count;\n        let b = 0;\n        for (let c = cStart; c < cEnd; c += 6, b++) {\n          const bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          const { bounds, leftCacheBounds, rightCacheBounds } = bin;\n          for (let d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n        let splitCount = count;\n        for (let bi = 0; bi < splitCount; bi++) {\n          const bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n        for (let c = cStart; c < cEnd; c += 6) {\n          const center = triangleBounds[c + 2 * a];\n          for (let bi = 0; bi < splitCount; bi++) {\n            const bin = truncatedBins[bi];\n            if (center >= bin.candidate) {\n              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);\n              bin.count++;\n            }\n          }\n        }\n        for (let bi = 0; bi < splitCount; bi++) {\n          const bin = truncatedBins[bi];\n          const leftCount = bin.count;\n          const rightCount = count - bin.count;\n          const leftBounds2 = bin.leftCacheBounds;\n          const rightBounds = bin.rightCacheBounds;\n          let leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;\n          }\n          let rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = bin.candidate;\n          }\n        }\n      } else {\n        for (let i = 0; i < BIN_COUNT; i++) {\n          const bin = sahBins[i];\n          bin.count = 0;\n          bin.candidate = axisLeft + binWidth + i * binWidth;\n          const bounds = bin.bounds;\n          for (let d = 0; d < 3; d++) {\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n        }\n        for (let c = cStart; c < cEnd; c += 6) {\n          const triCenter = triangleBounds[c + 2 * a];\n          const relativeCenter = triCenter - axisLeft;\n          let binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT)\n            binIndex = BIN_COUNT - 1;\n          const bin = sahBins[binIndex];\n          bin.count++;\n          expandByTriangleBounds(c, triangleBounds, bin.bounds);\n        }\n        const lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (let i = BIN_COUNT - 2; i >= 0; i--) {\n          const bin = sahBins[i];\n          const nextBin = sahBins[i + 1];\n          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n        }\n        let leftCount = 0;\n        for (let i = 0; i < BIN_COUNT - 1; i++) {\n          const bin = sahBins[i];\n          const binCount = bin.count;\n          const bounds = bin.bounds;\n          const nextBin = sahBins[i + 1];\n          const rightBounds = nextBin.rightCacheBounds;\n          if (binCount !== 0) {\n            if (leftCount === 0) {\n              copyBounds(bounds, leftBounds);\n            } else {\n              unionBounds(bounds, leftBounds, leftBounds);\n            }\n          }\n          leftCount += binCount;\n          let leftProb = 0;\n          let rightProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          const rightCount = count - leftCount;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = bin.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n  }\n  return { axis, pos };\n}\nfunction getAverage(triangleBounds, offset, count, axis) {\n  let avg = 0;\n  for (let i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}\nfunction computeTriangleBounds(geo, fullBounds) {\n  const posAttr = geo.attributes.position;\n  const posArr = posAttr.array;\n  const index = geo.index.array;\n  const triCount = index.length / 3;\n  const triangleBounds = new Float32Array(triCount * 6);\n  const bufferOffset = posAttr.offset || 0;\n  let stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n  for (let tri = 0; tri < triCount; tri++) {\n    const tri3 = tri * 3;\n    const tri6 = tri * 6;\n    const ai = index[tri3 + 0] * stride + bufferOffset;\n    const bi = index[tri3 + 1] * stride + bufferOffset;\n    const ci = index[tri3 + 2] * stride + bufferOffset;\n    for (let el = 0; el < 3; el++) {\n      const a = posArr[ai + el];\n      const b = posArr[bi + el];\n      const c = posArr[ci + el];\n      let min = a;\n      if (b < min)\n        min = b;\n      if (c < min)\n        min = c;\n      let max = a;\n      if (b > max)\n        max = b;\n      if (c > max)\n        max = c;\n      const halfExtents = (max - min) / 2;\n      const el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el])\n        fullBounds[el] = min;\n      if (max > fullBounds[el + 3])\n        fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}\nfunction buildTree(geo, options) {\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n        console.warn(geo);\n      }\n    }\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partition(indexArray, triangleBounds, offset, count, split);\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n  ensureIndex(geo, options);\n  const fullBounds = new Float32Array(6);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  const triangleBounds = computeTriangleBounds(geo, fullBounds);\n  const indexArray = geo.index.array;\n  const maxDepth = options.maxDepth;\n  const verbose = options.verbose;\n  const maxLeafTris = options.maxLeafTris;\n  const strategy = options.strategy;\n  const onProgress = options.onProgress;\n  const totalTriangles = geo.index.count / 3;\n  let reachedMaxDepth = false;\n  const roots = [];\n  const ranges = getRootIndexRanges(geo);\n  if (ranges.length === 1) {\n    const range = ranges[0];\n    const root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    for (let range of ranges) {\n      const root = new MeshBVHNode();\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n      roots.push(root);\n    }\n  }\n  return roots;\n}\nfunction buildPackedTree(geo, options) {\n  const roots = buildTree(geo, options);\n  let float32Array;\n  let uint32Array;\n  let uint16Array;\n  const packedRoots = [];\n  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    let nodeCount = countNodes(root);\n    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  return packedRoots;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = !!node.count;\n    const boundingData = node.boundingData;\n    for (let i = 0; i < 6; i++) {\n      float32Array[stride4Offset + i] = boundingData[i];\n    }\n    if (isLeaf) {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      const left = node.left;\n      const right = node.right;\n      const splitAxis = node.splitAxis;\n      let nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}\nclass SeparatingAxisBounds {\n  constructor() {\n    this.min = Infinity;\n    this.max = -Infinity;\n  }\n  setFromPointsField(points, field) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0, l = points.length; i < l; i++) {\n      const p = points[i];\n      const val = p[field];\n      min = val < min ? val : min;\n      max = val > max ? val : max;\n    }\n    this.min = min;\n    this.max = max;\n  }\n  setFromPoints(axis, points) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0, l = points.length; i < l; i++) {\n      const p = points[i];\n      const val = axis.dot(p);\n      min = val < min ? val : min;\n      max = val > max ? val : max;\n    }\n    this.min = min;\n    this.max = max;\n  }\n  isSeparated(other) {\n    return this.min > other.max || other.min > this.max;\n  }\n}\nSeparatingAxisBounds.prototype.setFromBox = function() {\n  const p = new Vector3();\n  return function setFromBox(axis, box) {\n    const boxMin = box.min;\n    const boxMax = box.max;\n    let min = Infinity;\n    let max = -Infinity;\n    for (let x = 0; x <= 1; x++) {\n      for (let y = 0; y <= 1; y++) {\n        for (let z = 0; z <= 1; z++) {\n          p.x = boxMin.x * x + boxMax.x * (1 - x);\n          p.y = boxMin.y * y + boxMax.y * (1 - y);\n          p.z = boxMin.z * z + boxMax.z * (1 - z);\n          const val = axis.dot(p);\n          min = Math.min(val, min);\n          max = Math.max(val, max);\n        }\n      }\n    }\n    this.min = min;\n    this.max = max;\n  };\n}();\n(function() {\n  const cacheSatBounds = new SeparatingAxisBounds();\n  return function areIntersecting(shape1, shape2) {\n    const points1 = shape1.points;\n    const satAxes1 = shape1.satAxes;\n    const satBounds1 = shape1.satBounds;\n    const points2 = shape2.points;\n    const satAxes2 = shape2.satAxes;\n    const satBounds2 = shape2.satBounds;\n    for (let i = 0; i < 3; i++) {\n      const sb = satBounds1[i];\n      const sa = satAxes1[i];\n      cacheSatBounds.setFromPoints(sa, points2);\n      if (sb.isSeparated(cacheSatBounds))\n        return false;\n    }\n    for (let i = 0; i < 3; i++) {\n      const sb = satBounds2[i];\n      const sa = satAxes2[i];\n      cacheSatBounds.setFromPoints(sa, points1);\n      if (sb.isSeparated(cacheSatBounds))\n        return false;\n    }\n  };\n})();\nconst closestPointLineToLine = function() {\n  const dir1 = new Vector3();\n  const dir2 = new Vector3();\n  const v02 = new Vector3();\n  return function closestPointLineToLine2(l1, l2, result) {\n    const v0 = l1.start;\n    const v10 = dir1;\n    const v2 = l2.start;\n    const v32 = dir2;\n    v02.subVectors(v0, v2);\n    dir1.subVectors(l1.end, l2.start);\n    dir2.subVectors(l2.end, l2.start);\n    const d0232 = v02.dot(v32);\n    const d3210 = v32.dot(v10);\n    const d3232 = v32.dot(v32);\n    const d0210 = v02.dot(v10);\n    const d1010 = v10.dot(v10);\n    const denom = d1010 * d3232 - d3210 * d3210;\n    let d, d2;\n    if (denom !== 0) {\n      d = (d0232 * d3210 - d0210 * d3232) / denom;\n    } else {\n      d = 0;\n    }\n    d2 = (d0232 + d * d3210) / d3232;\n    result.x = d;\n    result.y = d2;\n  };\n}();\nconst closestPointsSegmentToSegment = function() {\n  const paramResult = new Vector2();\n  const temp12 = new Vector3();\n  const temp22 = new Vector3();\n  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {\n    closestPointLineToLine(l1, l2, paramResult);\n    let d = paramResult.x;\n    let d2 = paramResult.y;\n    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n      l1.at(d, target1);\n      l2.at(d2, target2);\n      return;\n    } else if (d >= 0 && d <= 1) {\n      if (d2 < 0) {\n        l2.at(0, target2);\n      } else {\n        l2.at(1, target2);\n      }\n      l1.closestPointToPoint(target2, true, target1);\n      return;\n    } else if (d2 >= 0 && d2 <= 1) {\n      if (d < 0) {\n        l1.at(0, target1);\n      } else {\n        l1.at(1, target1);\n      }\n      l2.closestPointToPoint(target1, true, target2);\n      return;\n    } else {\n      let p;\n      if (d < 0) {\n        p = l1.start;\n      } else {\n        p = l1.end;\n      }\n      let p2;\n      if (d2 < 0) {\n        p2 = l2.start;\n      } else {\n        p2 = l2.end;\n      }\n      const closestPoint = temp12;\n      const closestPoint2 = temp22;\n      l1.closestPointToPoint(p2, true, temp12);\n      l2.closestPointToPoint(p, true, temp22);\n      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n        target1.copy(closestPoint);\n        target2.copy(p2);\n        return;\n      } else {\n        target1.copy(p);\n        target2.copy(closestPoint2);\n        return;\n      }\n    }\n  };\n}();\nconst sphereIntersectTriangle = function() {\n  const closestPointTemp = new Vector3();\n  const projectedPointTemp = new Vector3();\n  const planeTemp = new Plane();\n  const lineTemp = new Line3();\n  return function sphereIntersectTriangle2(sphere, triangle) {\n    const { radius, center } = sphere;\n    const { a, b, c } = triangle;\n    lineTemp.start = a;\n    lineTemp.end = b;\n    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint1.distanceTo(center) <= radius)\n      return true;\n    lineTemp.start = a;\n    lineTemp.end = c;\n    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint2.distanceTo(center) <= radius)\n      return true;\n    lineTemp.start = b;\n    lineTemp.end = c;\n    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint3.distanceTo(center) <= radius)\n      return true;\n    const plane = triangle.getPlane(planeTemp);\n    const dp = Math.abs(plane.distanceToPoint(center));\n    if (dp <= radius) {\n      const pp = plane.projectPoint(center, projectedPointTemp);\n      const cp = triangle.containsPoint(pp);\n      if (cp)\n        return true;\n    }\n    return false;\n  };\n}();\nclass SeparatingAxisTriangle extends Triangle {\n  constructor(...args) {\n    super(...args);\n    this.isSeparatingAxisTriangle = true;\n    this.satAxes = new Array(4).fill().map(() => new Vector3());\n    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());\n    this.points = [this.a, this.b, this.c];\n    this.sphere = new Sphere();\n    this.plane = new Plane();\n    this.needsUpdate = false;\n  }\n  intersectsSphere(sphere) {\n    return sphereIntersectTriangle(sphere, this);\n  }\n  update() {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const points = this.points;\n    const satAxes = this.satAxes;\n    const satBounds = this.satBounds;\n    const axis0 = satAxes[0];\n    const sab0 = satBounds[0];\n    this.getNormal(axis0);\n    sab0.setFromPoints(axis0, points);\n    const axis1 = satAxes[1];\n    const sab1 = satBounds[1];\n    axis1.subVectors(a, b);\n    sab1.setFromPoints(axis1, points);\n    const axis2 = satAxes[2];\n    const sab2 = satBounds[2];\n    axis2.subVectors(b, c);\n    sab2.setFromPoints(axis2, points);\n    const axis3 = satAxes[3];\n    const sab3 = satBounds[3];\n    axis3.subVectors(c, a);\n    sab3.setFromPoints(axis3, points);\n    this.sphere.setFromPoints(this.points);\n    this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n    this.needsUpdate = false;\n  }\n}\nSeparatingAxisTriangle.prototype.closestPointToSegment = function() {\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  const edge = new Line3();\n  return function distanceToSegment(segment, target1 = null, target2 = null) {\n    const { start, end } = segment;\n    const points = this.points;\n    let distSq;\n    let closestDistanceSq = Infinity;\n    for (let i = 0; i < 3; i++) {\n      const nexti = (i + 1) % 3;\n      edge.start.copy(points[i]);\n      edge.end.copy(points[nexti]);\n      closestPointsSegmentToSegment(edge, segment, point1, point2);\n      distSq = point1.distanceToSquared(point2);\n      if (distSq < closestDistanceSq) {\n        closestDistanceSq = distSq;\n        if (target1)\n          target1.copy(point1);\n        if (target2)\n          target2.copy(point2);\n      }\n    }\n    this.closestPointToPoint(start, point1);\n    distSq = start.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1)\n        target1.copy(point1);\n      if (target2)\n        target2.copy(start);\n    }\n    this.closestPointToPoint(end, point1);\n    distSq = end.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1)\n        target1.copy(point1);\n      if (target2)\n        target2.copy(end);\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\nSeparatingAxisTriangle.prototype.intersectsTriangle = function() {\n  const saTri2 = new SeparatingAxisTriangle();\n  const arr1 = new Array(3);\n  const arr2 = new Array(3);\n  const cachedSatBounds = new SeparatingAxisBounds();\n  const cachedSatBounds2 = new SeparatingAxisBounds();\n  const cachedAxis = new Vector3();\n  const dir1 = new Vector3();\n  const dir2 = new Vector3();\n  const tempDir = new Vector3();\n  const edge = new Line3();\n  const edge1 = new Line3();\n  const edge2 = new Line3();\n  return function intersectsTriangle(other, target = null) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (!other.isSeparatingAxisTriangle) {\n      saTri2.copy(other);\n      saTri2.update();\n      other = saTri2;\n    } else if (other.needsUpdate) {\n      other.update();\n    }\n    const satBounds1 = this.satBounds;\n    const satAxes1 = this.satAxes;\n    arr2[0] = other.a;\n    arr2[1] = other.b;\n    arr2[2] = other.c;\n    for (let i = 0; i < 4; i++) {\n      const sb = satBounds1[i];\n      const sa = satAxes1[i];\n      cachedSatBounds.setFromPoints(sa, arr2);\n      if (sb.isSeparated(cachedSatBounds))\n        return false;\n    }\n    const satBounds2 = other.satBounds;\n    const satAxes2 = other.satAxes;\n    arr1[0] = this.a;\n    arr1[1] = this.b;\n    arr1[2] = this.c;\n    for (let i = 0; i < 4; i++) {\n      const sb = satBounds2[i];\n      const sa = satAxes2[i];\n      cachedSatBounds.setFromPoints(sa, arr1);\n      if (sb.isSeparated(cachedSatBounds))\n        return false;\n    }\n    for (let i = 0; i < 4; i++) {\n      const sa1 = satAxes1[i];\n      for (let i2 = 0; i2 < 4; i2++) {\n        const sa2 = satAxes2[i2];\n        cachedAxis.crossVectors(sa1, sa2);\n        cachedSatBounds.setFromPoints(cachedAxis, arr1);\n        cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n        if (cachedSatBounds.isSeparated(cachedSatBounds2))\n          return false;\n      }\n    }\n    if (target) {\n      const plane1 = this.plane;\n      const plane2 = other.plane;\n      if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {\n        console.warn(\"SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.\");\n        target.start.set(0, 0, 0);\n        target.end.set(0, 0, 0);\n      } else {\n        const points1 = this.points;\n        let found1 = false;\n        for (let i = 0; i < 3; i++) {\n          const p1 = points1[i];\n          const p2 = points1[(i + 1) % 3];\n          edge.start.copy(p1);\n          edge.end.copy(p2);\n          if (plane2.intersectLine(edge, found1 ? edge1.start : edge1.end)) {\n            if (found1) {\n              break;\n            }\n            found1 = true;\n          }\n        }\n        const points2 = other.points;\n        let found2 = false;\n        for (let i = 0; i < 3; i++) {\n          const p1 = points2[i];\n          const p2 = points2[(i + 1) % 3];\n          edge.start.copy(p1);\n          edge.end.copy(p2);\n          if (plane1.intersectLine(edge, found2 ? edge2.start : edge2.end)) {\n            if (found2) {\n              break;\n            }\n            found2 = true;\n          }\n        }\n        edge1.delta(dir1);\n        edge2.delta(dir2);\n        if (dir1.dot(dir2) < 0) {\n          let tmp = edge2.start;\n          edge2.start = edge2.end;\n          edge2.end = tmp;\n        }\n        tempDir.subVectors(edge1.start, edge2.start);\n        if (tempDir.dot(dir1) > 0) {\n          target.start.copy(edge1.start);\n        } else {\n          target.start.copy(edge2.start);\n        }\n        tempDir.subVectors(edge1.end, edge2.end);\n        if (tempDir.dot(dir1) < 0) {\n          target.end.copy(edge1.end);\n        } else {\n          target.end.copy(edge2.end);\n        }\n      }\n    }\n    return true;\n  };\n}();\nSeparatingAxisTriangle.prototype.distanceToPoint = function() {\n  const target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\nSeparatingAxisTriangle.prototype.distanceToTriangle = function() {\n  const point = new Vector3();\n  const point2 = new Vector3();\n  const cornerFields = [\"a\", \"b\", \"c\"];\n  const line1 = new Line3();\n  const line2 = new Line3();\n  return function distanceToTriangle(other, target1 = null, target2 = null) {\n    const lineTarget = target1 || target2 ? line1 : null;\n    if (this.intersectsTriangle(other, lineTarget)) {\n      if (target1 || target2) {\n        if (target1)\n          lineTarget.getCenter(target1);\n        if (target2)\n          lineTarget.getCenter(target2);\n      }\n      return 0;\n    }\n    let closestDistanceSq = Infinity;\n    for (let i = 0; i < 3; i++) {\n      let dist;\n      const field = cornerFields[i];\n      const otherVec = other[field];\n      this.closestPointToPoint(otherVec, point);\n      dist = otherVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1)\n          target1.copy(point);\n        if (target2)\n          target2.copy(otherVec);\n      }\n      const thisVec = this[field];\n      other.closestPointToPoint(thisVec, point);\n      dist = thisVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1)\n          target1.copy(thisVec);\n        if (target2)\n          target2.copy(point);\n      }\n    }\n    for (let i = 0; i < 3; i++) {\n      const f11 = cornerFields[i];\n      const f12 = cornerFields[(i + 1) % 3];\n      line1.set(this[f11], this[f12]);\n      for (let i2 = 0; i2 < 3; i2++) {\n        const f21 = cornerFields[i2];\n        const f22 = cornerFields[(i2 + 1) % 3];\n        line2.set(other[f21], other[f22]);\n        closestPointsSegmentToSegment(line1, line2, point, point2);\n        const dist = point.distanceToSquared(point2);\n        if (dist < closestDistanceSq) {\n          closestDistanceSq = dist;\n          if (target1)\n            target1.copy(point);\n          if (target2)\n            target2.copy(point2);\n        }\n      }\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\nclass OrientedBox extends Box3 {\n  constructor(...args) {\n    super(...args);\n    this.isOrientedBox = true;\n    this.matrix = new Matrix4();\n    this.invMatrix = new Matrix4();\n    this.points = new Array(8).fill().map(() => new Vector3());\n    this.satAxes = new Array(3).fill().map(() => new Vector3());\n    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());\n    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());\n    this.needsUpdate = false;\n  }\n  set(min, max, matrix) {\n    super.set(min, max);\n    this.matrix = matrix;\n    this.needsUpdate = true;\n  }\n  copy(other) {\n    super.copy(other);\n    this.matrix.copy(other.matrix);\n    this.needsUpdate = true;\n  }\n}\nOrientedBox.prototype.update = function() {\n  return function update() {\n    const matrix = this.matrix;\n    const min = this.min;\n    const max = this.max;\n    const points = this.points;\n    for (let x = 0; x <= 1; x++) {\n      for (let y = 0; y <= 1; y++) {\n        for (let z = 0; z <= 1; z++) {\n          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;\n          const v = points[i];\n          v.x = x ? max.x : min.x;\n          v.y = y ? max.y : min.y;\n          v.z = z ? max.z : min.z;\n          v.applyMatrix4(matrix);\n        }\n      }\n    }\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    const minVec = points[0];\n    for (let i = 0; i < 3; i++) {\n      const axis = satAxes[i];\n      const sb = satBounds[i];\n      const index = 1 << i;\n      const pi = points[index];\n      axis.subVectors(minVec, pi);\n      sb.setFromPoints(axis, points);\n    }\n    const alignedSatBounds = this.alignedSatBounds;\n    alignedSatBounds[0].setFromPointsField(points, \"x\");\n    alignedSatBounds[1].setFromPointsField(points, \"y\");\n    alignedSatBounds[2].setFromPointsField(points, \"z\");\n    this.invMatrix.copy(this.matrix).invert();\n    this.needsUpdate = false;\n  };\n}();\nOrientedBox.prototype.intersectsBox = function() {\n  const aabbBounds = new SeparatingAxisBounds();\n  return function intersectsBox(box) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    const min = box.min;\n    const max = box.max;\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    const alignedSatBounds = this.alignedSatBounds;\n    aabbBounds.min = min.x;\n    aabbBounds.max = max.x;\n    if (alignedSatBounds[0].isSeparated(aabbBounds))\n      return false;\n    aabbBounds.min = min.y;\n    aabbBounds.max = max.y;\n    if (alignedSatBounds[1].isSeparated(aabbBounds))\n      return false;\n    aabbBounds.min = min.z;\n    aabbBounds.max = max.z;\n    if (alignedSatBounds[2].isSeparated(aabbBounds))\n      return false;\n    for (let i = 0; i < 3; i++) {\n      const axis = satAxes[i];\n      const sb = satBounds[i];\n      aabbBounds.setFromBox(axis, box);\n      if (sb.isSeparated(aabbBounds))\n        return false;\n    }\n    return true;\n  };\n}();\nOrientedBox.prototype.intersectsTriangle = function() {\n  const saTri = new SeparatingAxisTriangle();\n  const pointsArr = new Array(3);\n  const cachedSatBounds = new SeparatingAxisBounds();\n  const cachedSatBounds2 = new SeparatingAxisBounds();\n  const cachedAxis = new Vector3();\n  return function intersectsTriangle(triangle) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (!triangle.isSeparatingAxisTriangle) {\n      saTri.copy(triangle);\n      saTri.update();\n      triangle = saTri;\n    } else if (triangle.needsUpdate) {\n      triangle.update();\n    }\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    pointsArr[0] = triangle.a;\n    pointsArr[1] = triangle.b;\n    pointsArr[2] = triangle.c;\n    for (let i = 0; i < 3; i++) {\n      const sb = satBounds[i];\n      const sa = satAxes[i];\n      cachedSatBounds.setFromPoints(sa, pointsArr);\n      if (sb.isSeparated(cachedSatBounds))\n        return false;\n    }\n    const triSatBounds = triangle.satBounds;\n    const triSatAxes = triangle.satAxes;\n    const points = this.points;\n    for (let i = 0; i < 3; i++) {\n      const sb = triSatBounds[i];\n      const sa = triSatAxes[i];\n      cachedSatBounds.setFromPoints(sa, points);\n      if (sb.isSeparated(cachedSatBounds))\n        return false;\n    }\n    for (let i = 0; i < 3; i++) {\n      const sa1 = satAxes[i];\n      for (let i2 = 0; i2 < 4; i2++) {\n        const sa2 = triSatAxes[i2];\n        cachedAxis.crossVectors(sa1, sa2);\n        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n        cachedSatBounds2.setFromPoints(cachedAxis, points);\n        if (cachedSatBounds.isSeparated(cachedSatBounds2))\n          return false;\n      }\n    }\n    return true;\n  };\n}();\nOrientedBox.prototype.closestPointToPoint = function() {\n  return function closestPointToPoint(point, target1) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n    return target1;\n  };\n}();\nOrientedBox.prototype.distanceToPoint = function() {\n  const target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\nOrientedBox.prototype.distanceToBox = function() {\n  const xyzFields2 = [\"x\", \"y\", \"z\"];\n  const segments1 = new Array(12).fill().map(() => new Line3());\n  const segments2 = new Array(12).fill().map(() => new Line3());\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (this.intersectsBox(box)) {\n      if (target1 || target2) {\n        box.getCenter(point2);\n        this.closestPointToPoint(point2, point1);\n        box.closestPointToPoint(point1, point2);\n        if (target1)\n          target1.copy(point1);\n        if (target2)\n          target2.copy(point2);\n      }\n      return 0;\n    }\n    const threshold2 = threshold * threshold;\n    const min = box.min;\n    const max = box.max;\n    const points = this.points;\n    let closestDistanceSq = Infinity;\n    for (let i = 0; i < 8; i++) {\n      const p = points[i];\n      point2.copy(p).clamp(min, max);\n      const dist = p.distanceToSquared(point2);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1)\n          target1.copy(p);\n        if (target2)\n          target2.copy(point2);\n        if (dist < threshold2)\n          return Math.sqrt(dist);\n      }\n    }\n    let count = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let i1 = 0; i1 <= 1; i1++) {\n        for (let i2 = 0; i2 <= 1; i2++) {\n          const nextIndex = (i + 1) % 3;\n          const nextIndex2 = (i + 2) % 3;\n          const index = i1 << nextIndex | i2 << nextIndex2;\n          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n          const p1 = points[index];\n          const p2 = points[index2];\n          const line1 = segments1[count];\n          line1.set(p1, p2);\n          const f1 = xyzFields2[i];\n          const f2 = xyzFields2[nextIndex];\n          const f3 = xyzFields2[nextIndex2];\n          const line2 = segments2[count];\n          const start = line2.start;\n          const end = line2.end;\n          start[f1] = min[f1];\n          start[f2] = i1 ? min[f2] : max[f2];\n          start[f3] = i2 ? min[f3] : max[f2];\n          end[f1] = max[f1];\n          end[f2] = i1 ? min[f2] : max[f2];\n          end[f3] = i2 ? min[f3] : max[f2];\n          count++;\n        }\n      }\n    }\n    for (let x = 0; x <= 1; x++) {\n      for (let y = 0; y <= 1; y++) {\n        for (let z = 0; z <= 1; z++) {\n          point2.x = x ? max.x : min.x;\n          point2.y = y ? max.y : min.y;\n          point2.z = z ? max.z : min.z;\n          this.closestPointToPoint(point2, point1);\n          const dist = point2.distanceToSquared(point1);\n          if (dist < closestDistanceSq) {\n            closestDistanceSq = dist;\n            if (target1)\n              target1.copy(point1);\n            if (target2)\n              target2.copy(point2);\n            if (dist < threshold2)\n              return Math.sqrt(dist);\n          }\n        }\n      }\n    }\n    for (let i = 0; i < 12; i++) {\n      const l1 = segments1[i];\n      for (let i2 = 0; i2 < 12; i2++) {\n        const l2 = segments2[i2];\n        closestPointsSegmentToSegment(l1, l2, point1, point2);\n        const dist = point1.distanceToSquared(point2);\n        if (dist < closestDistanceSq) {\n          closestDistanceSq = dist;\n          if (target1)\n            target1.copy(point1);\n          if (target2)\n            target2.copy(point2);\n          if (dist < threshold2)\n            return Math.sqrt(dist);\n        }\n      }\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection(ray, pA, pB, pC, point, side) {\n  let intersect;\n  if (side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);\n  }\n  if (intersect === null)\n    return null;\n  const distance = ray.origin.distanceTo(point);\n  return {\n    distance,\n    point: point.clone()\n  };\n}\nfunction checkBufferGeometryIntersection(ray, position, uv, a, b, c, side) {\n  vA.fromBufferAttribute(position, a);\n  vB.fromBufferAttribute(position, b);\n  vC.fromBufferAttribute(position, c);\n  const intersection = checkIntersection(ray, vA, vB, vC, intersectionPoint, side);\n  if (intersection) {\n    if (uv) {\n      uvA.fromBufferAttribute(uv, a);\n      uvB.fromBufferAttribute(uv, b);\n      uvC.fromBufferAttribute(uv, c);\n      intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());\n    }\n    const face = {\n      a,\n      b,\n      c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(vA, vB, vC, face.normal);\n    intersection.face = face;\n    intersection.faceIndex = a;\n  }\n  return intersection;\n}\nfunction intersectTri(geo, side, ray, tri, intersections) {\n  const triOffset = tri * 3;\n  const a = geo.index.getX(triOffset);\n  const b = geo.index.getX(triOffset + 1);\n  const c = geo.index.getX(triOffset + 2);\n  const intersection = checkBufferGeometryIntersection(ray, geo.attributes.position, geo.attributes.uv, a, b, c, side);\n  if (intersection) {\n    intersection.faceIndex = tri;\n    if (intersections)\n      intersections.push(intersection);\n    return intersection;\n  }\n  return null;\n}\nfunction intersectTris(geo, side, ray, offset, count, intersections) {\n  for (let i = offset, end = offset + count; i < end; i++) {\n    intersectTri(geo, side, ray, i, intersections);\n  }\n}\nfunction intersectClosestTri(geo, side, ray, offset, count) {\n  let dist = Infinity;\n  let res = null;\n  for (let i = offset, end = offset + count; i < end; i++) {\n    const intersection = intersectTri(geo, side, ray, i);\n    if (intersection && intersection.distance < dist) {\n      res = intersection;\n      dist = intersection.distance;\n    }\n  }\n  return res;\n}\nfunction convertRaycastIntersect(hit, object, raycaster) {\n  if (hit === null) {\n    return null;\n  }\n  hit.point.applyMatrix4(object.matrixWorld);\n  hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n  hit.object = object;\n  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {\n    return null;\n  } else {\n    return hit;\n  }\n}\nfunction setTriangle(tri, i, index, pos) {\n  const ta = tri.a;\n  const tb = tri.b;\n  const tc = tri.c;\n  let i0 = i;\n  let i1 = i + 1;\n  let i2 = i + 2;\n  if (index) {\n    i0 = index.getX(i);\n    i1 = index.getX(i + 1);\n    i2 = index.getX(i + 2);\n  }\n  ta.x = pos.getX(i0);\n  ta.y = pos.getY(i0);\n  ta.z = pos.getZ(i0);\n  tb.x = pos.getX(i1);\n  tb.y = pos.getY(i1);\n  tb.z = pos.getZ(i1);\n  tc.x = pos.getX(i2);\n  tc.y = pos.getY(i2);\n  tc.z = pos.getZ(i2);\n}\nfunction iterateOverTriangles(offset, count, geometry, intersectsTriangleFunc, contained, depth, triangle) {\n  const index = geometry.index;\n  const pos = geometry.attributes.position;\n  for (let i = offset, l = count + offset; i < l; i++) {\n    setTriangle(triangle, i * 3, index, pos);\n    triangle.needsUpdate = true;\n    if (intersectsTriangleFunc(triangle, i, contained, depth)) {\n      return true;\n    }\n  }\n  return false;\n}\nclass PrimitivePool {\n  constructor(getNewPrimitive) {\n    this._getNewPrimitive = getNewPrimitive;\n    this._primitives = [];\n  }\n  getPrimitive() {\n    const primitives = this._primitives;\n    if (primitives.length === 0) {\n      return this._getNewPrimitive();\n    } else {\n      return primitives.pop();\n    }\n  }\n  releasePrimitive(primitive) {\n    this._primitives.push(primitive);\n  }\n}\nfunction IS_LEAF(n16, uint16Array) {\n  return uint16Array[n16 + 15] === 65535;\n}\nfunction OFFSET(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\nfunction COUNT(n16, uint16Array) {\n  return uint16Array[n16 + 14];\n}\nfunction LEFT_NODE(n32) {\n  return n32 + 8;\n}\nfunction RIGHT_NODE(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\nfunction SPLIT_AXIS(n32, uint32Array) {\n  return uint32Array[n32 + 7];\n}\nfunction BOUNDING_DATA_INDEX(n32) {\n  return n32;\n}\nconst boundingBox$1 = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [\"x\", \"y\", \"z\"];\nfunction raycast(nodeIndex32, geometry, side, ray, intersects) {\n  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    intersectTris(geometry, side, ray, offset, count, intersects);\n  } else {\n    const leftIndex = LEFT_NODE(nodeIndex32);\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, geometry, side, ray, intersects);\n    }\n    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, geometry, side, ray, intersects);\n    }\n  }\n}\nfunction raycastFirst(nodeIndex32, geometry, side, ray) {\n  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(geometry, side, ray, offset, count);\n  } else {\n    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    const xyzAxis = xyzFields[splitAxis];\n    const rayDir = ray.direction[xyzAxis];\n    const leftToRight = rayDir >= 0;\n    let c1, c2;\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n    const c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    const c1Result = c1Intersection ? raycastFirst(c1, geometry, side, ray) : null;\n    if (c1Result) {\n      const point = c1Result.point[xyzAxis];\n      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3];\n      if (isOutside) {\n        return c1Result;\n      }\n    }\n    const c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    const c2Result = c2Intersection ? raycastFirst(c2, geometry, side, ray) : null;\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nconst shapecast = function() {\n  let _box1, _box2;\n  const boxStack = [];\n  const boxPool = new PrimitivePool(() => new Box3());\n  return function shapecast2(...args) {\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    const result = shapecastTraverse(...args);\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    const length = boxStack.length;\n    if (length > 0) {\n      _box2 = boxStack[length - 1];\n      _box1 = boxStack[length - 2];\n    }\n    return result;\n  };\n  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {\n    function getLeftOffset(nodeIndex322) {\n      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;\n      while (!IS_LEAF(nodeIndex162, uint16Array2)) {\n        nodeIndex322 = LEFT_NODE(nodeIndex322);\n        nodeIndex162 = nodeIndex322 * 2;\n      }\n      return OFFSET(nodeIndex322, uint32Array2);\n    }\n    function getRightEndOffset(nodeIndex322) {\n      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;\n      while (!IS_LEAF(nodeIndex162, uint16Array2)) {\n        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);\n        nodeIndex162 = nodeIndex322 * 2;\n      }\n      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);\n    }\n    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array);\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n      const left = LEFT_NODE(nodeIndex32);\n      const right = RIGHT_NODE(nodeIndex32, uint32Array);\n      let c1 = left;\n      let c2 = right;\n      let score1, score2;\n      let box1, box2;\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          const temp5 = score1;\n          score1 = score2;\n          score2 = temp5;\n          box1 = box2;\n        }\n      }\n      if (!box1) {\n        box1 = _box1;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n      const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      let c1StopTraversal;\n      if (c1Intersection === CONTAINED) {\n        const offset = getLeftOffset(c1);\n        const end = getRightEndOffset(c1);\n        const count = end - offset;\n        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c1StopTraversal)\n        return true;\n      box2 = _box2;\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      let c2StopTraversal;\n      if (c2Intersection === CONTAINED) {\n        const offset = getLeftOffset(c2);\n        const end = getRightEndOffset(c2);\n        const count = end - offset;\n        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n      if (c2StopTraversal)\n        return true;\n      return false;\n    }\n  }\n}();\nconst intersectsGeometry = function() {\n  const triangle = new SeparatingAxisTriangle();\n  const triangle2 = new SeparatingAxisTriangle();\n  const invertedMat = new Matrix4();\n  const obb3 = new OrientedBox();\n  const obb22 = new OrientedBox();\n  return function intersectsGeometry2(nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null) {\n    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n      obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb3;\n    }\n    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n    if (isLeaf) {\n      const thisGeometry = geometry;\n      const thisIndex = thisGeometry.index;\n      const thisPos = thisGeometry.attributes.position;\n      const index = otherGeometry.index;\n      const pos = otherGeometry.attributes.position;\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const count = COUNT(nodeIndex16, uint16Array);\n      invertedMat.copy(geometryToBvh).invert();\n      if (otherGeometry.boundsTree) {\n        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb22);\n        obb22.matrix.copy(invertedMat);\n        obb22.needsUpdate = true;\n        const res = otherGeometry.boundsTree.shapecast({\n          intersectsBounds: (box) => obb22.intersectsBox(box),\n          intersectsTriangle: (tri) => {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n            for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n            return false;\n          }\n        });\n        return res;\n      } else {\n        for (let i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n          for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      const left = nodeIndex32 + 8;\n      const right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox$1);\n      const leftIntersection = cachedObb.intersectsBox(boundingBox$1) && intersectsGeometry2(left, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection)\n        return true;\n      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox$1);\n      const rightIntersection = cachedObb.intersectsBox(boundingBox$1) && intersectsGeometry2(right, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection)\n        return true;\n      return false;\n    }\n  };\n}();\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox$1);\n  return ray.intersectBox(boundingBox$1, target);\n}\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nfunction setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nfunction clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}\nconst SKIP_GENERATION = Symbol(\"skip tree generation\");\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool(() => new SeparatingAxisTriangle());\nclass MeshBVH {\n  static serialize(bvh, options = {}) {\n    if (options.isBufferGeometry) {\n      console.warn(\"MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.\");\n      return MeshBVH.serialize(arguments[0], {\n        cloneBuffers: arguments[2] === void 0 ? true : arguments[2]\n      });\n    }\n    options = __spreadValues({\n      cloneBuffers: true\n    }, options);\n    const geometry = bvh.geometry;\n    const rootData = bvh._roots;\n    const indexAttribute = geometry.getIndex();\n    let result;\n    if (options.cloneBuffers) {\n      result = {\n        roots: rootData.map((root) => root.slice()),\n        index: indexAttribute.array.slice()\n      };\n    } else {\n      result = {\n        roots: rootData,\n        index: indexAttribute.array\n      };\n    }\n    return result;\n  }\n  static deserialize(data, geometry, options = {}) {\n    if (typeof options === \"boolean\") {\n      console.warn(\"MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.\");\n      return MeshBVH.deserialize(arguments[0], arguments[1], {\n        setIndex: arguments[2] === void 0 ? true : arguments[2]\n      });\n    }\n    options = __spreadValues({\n      setIndex: true\n    }, options);\n    const { index, roots } = data;\n    const bvh = new MeshBVH(geometry, __spreadProps(__spreadValues({}, options), { [SKIP_GENERATION]: true }));\n    bvh._roots = roots;\n    if (options.setIndex) {\n      const indexAttribute = geometry.getIndex();\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n    return bvh;\n  }\n  constructor(geometry, options = {}) {\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n    }\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      [SKIP_GENERATION]: false\n    }, options);\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === \"undefined\") {\n      throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n    }\n    this._roots = null;\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    this.geometry = geometry;\n  }\n  refit(nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n      nodeIndices = new Set(nodeIndices);\n    }\n    const geometry = this.geometry;\n    const indexArr = geometry.index.array;\n    const posAttr = geometry.attributes.position;\n    const posArr = posAttr.array;\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) {\n      stride = posAttr.data.stride;\n    }\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = this._roots;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      buffer = roots[i];\n      uint32Array = new Uint32Array(buffer);\n      uint16Array = new Uint16Array(buffer);\n      float32Array = new Float32Array(buffer);\n      _traverse(0, byteOffset);\n      byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset2, force = false) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        let minx = Infinity;\n        let miny = Infinity;\n        let minz = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        let maxz = -Infinity;\n        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n          const index = indexArr[i] * stride + bufferOffset;\n          const x = posArr[index + 0];\n          const y = posArr[index + 1];\n          const z = posArr[index + 2];\n          if (x < minx)\n            minx = x;\n          if (x > maxx)\n            maxx = x;\n          if (y < miny)\n            miny = y;\n          if (y > maxy)\n            maxy = y;\n          if (z < minz)\n            minz = z;\n          if (z > maxz)\n            maxz = z;\n        }\n        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n          float32Array[node32Index + 0] = minx;\n          float32Array[node32Index + 1] = miny;\n          float32Array[node32Index + 2] = minz;\n          float32Array[node32Index + 3] = maxx;\n          float32Array[node32Index + 4] = maxy;\n          float32Array[node32Index + 5] = maxz;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        const left = node32Index + 8;\n        const right = uint32Array[node32Index + 6];\n        const offsetLeft = left + byteOffset2;\n        const offsetRight = right + byteOffset2;\n        let forceChildren = force;\n        let includesLeft = false;\n        let includesRight = false;\n        if (nodeIndices) {\n          if (!forceChildren) {\n            includesLeft = nodeIndices.has(offsetLeft);\n            includesRight = nodeIndices.has(offsetRight);\n            forceChildren = !includesLeft && !includesRight;\n          }\n        } else {\n          includesLeft = true;\n          includesRight = true;\n        }\n        const traverseLeft = forceChildren || includesLeft;\n        const traverseRight = forceChildren || includesRight;\n        let leftChange = false;\n        if (traverseLeft) {\n          leftChange = _traverse(left, byteOffset2, forceChildren);\n        }\n        let rightChange = false;\n        if (traverseRight) {\n          rightChange = _traverse(right, byteOffset2, forceChildren);\n        }\n        const didChange = leftChange || rightChange;\n        if (didChange) {\n          for (let i = 0; i < 3; i++) {\n            const lefti = left + i;\n            const righti = right + i;\n            const minLeftValue = float32Array[lefti];\n            const maxLeftValue = float32Array[lefti + 3];\n            const minRightValue = float32Array[righti];\n            const maxRightValue = float32Array[righti + 3];\n            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n          }\n        }\n        return didChange;\n      }\n    }\n  }\n  traverse(callback, rootIndex = 0) {\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n    _traverse(0);\n    function _traverse(node32Index, depth = 0) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n  raycast(ray, materialOrSide = FrontSide) {\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const intersects = [];\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const startCount = intersects.length;\n      setBuffer(roots[i]);\n      raycast(0, geometry, materialSide, ray, intersects);\n      clearBuffer();\n      if (isArrayMaterial) {\n        const materialIndex = groups[i].materialIndex;\n        for (let j = startCount, jl = intersects.length; j < jl; j++) {\n          intersects[j].face.materialIndex = materialIndex;\n        }\n      }\n    }\n    return intersects;\n  }\n  raycastFirst(ray, materialOrSide = FrontSide) {\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    let closestResult = null;\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      setBuffer(roots[i]);\n      const result = raycastFirst(0, geometry, materialSide, ray);\n      clearBuffer();\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n        if (isArrayMaterial) {\n          result.face.materialIndex = groups[i].materialIndex;\n        }\n      }\n    }\n    return closestResult;\n  }\n  intersectsGeometry(otherGeometry, geomToMesh) {\n    const geometry = this.geometry;\n    let result = false;\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n      clearBuffer();\n      if (result) {\n        break;\n      }\n    }\n    return result;\n  }\n  shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n    const geometry = this.geometry;\n    if (callbacks instanceof Function) {\n      if (_intersectsTriangleFunc) {\n        const originalTriangleFunc = _intersectsTriangleFunc;\n        _intersectsTriangleFunc = (tri, index, contained, depth) => {\n          const i3 = index * 3;\n          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n        };\n      }\n      callbacks = {\n        boundsTraverseOrder: _orderNodesFunc,\n        intersectsBounds: callbacks,\n        intersectsTriangle: _intersectsTriangleFunc,\n        intersectsRange: null\n      };\n      console.warn(\"MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.\");\n    }\n    const triangle = trianglePool.getPrimitive();\n    let { boundsTraverseOrder, intersectsBounds, intersectsRange, intersectsTriangle } = callbacks;\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        }\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n    let result = false;\n    let byteOffset = 0;\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      clearBuffer();\n      if (result) {\n        break;\n      }\n      byteOffset += root.byteLength;\n    }\n    trianglePool.releasePrimitive(triangle);\n    return result;\n  }\n  bvhcast(otherBvh, matrixToLocal, callbacks) {\n    let { intersectsRanges, intersectsTriangles } = callbacks;\n    const indexAttr = this.geometry.index;\n    const positionAttr = this.geometry.attributes.position;\n    const otherIndexAttr = otherBvh.geometry.index;\n    const otherPositionAttr = otherBvh.geometry.attributes.position;\n    tempMatrix.copy(matrixToLocal).invert();\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n    if (intersectsTriangles) {\n      let iterateOverDoubleTriangles = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n          setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n          triangle2.a.applyMatrix4(matrixToLocal);\n          triangle2.b.applyMatrix4(matrixToLocal);\n          triangle2.c.applyMatrix4(matrixToLocal);\n          triangle2.needsUpdate = true;\n          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n            setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n            triangle.needsUpdate = true;\n            if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n      if (intersectsRanges) {\n        const originalIntersectsRanges = intersectsRanges;\n        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n          }\n          return true;\n        };\n      } else {\n        intersectsRanges = iterateOverDoubleTriangles;\n      }\n    }\n    this.getBoundingBox(aabb2);\n    aabb2.applyMatrix4(matrixToLocal);\n    const result = this.shapecast({\n      intersectsBounds: (box) => aabb2.intersectsBox(box),\n      intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {\n        aabb.copy(box);\n        aabb.applyMatrix4(tempMatrix);\n        return otherBvh.shapecast({\n          intersectsBounds: (box2) => aabb.intersectsBox(box2),\n          intersectsRange: (offset2, count2, contained2, depth2, nodeIndex2) => {\n            return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n          }\n        });\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    return result;\n  }\n  intersectsBox(box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast({\n      intersectsBounds: (box2) => obb.intersectsBox(box2),\n      intersectsTriangle: (tri) => obb.intersectsTriangle(tri)\n    });\n  }\n  intersectsSphere(sphere) {\n    return this.shapecast({\n      intersectsBounds: (box) => sphere.intersectsBox(box),\n      intersectsTriangle: (tri) => tri.intersectsSphere(sphere)\n    });\n  }\n  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = this.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n      tempTarget2 = temp3;\n      tempTargetDest2 = temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    this.shapecast({\n      boundsTraverseOrder: (box) => {\n        return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        if (score < closestDistance && score < maxThreshold) {\n          if (isLeaf) {\n            obb2.min.copy(box.min);\n            obb2.max.copy(box.max);\n            obb2.needsUpdate = true;\n          }\n          return true;\n        }\n        return false;\n      },\n      intersectsRange: (offset, count) => {\n        if (otherGeometry.boundsTree) {\n          return otherGeometry.boundsTree.shapecast({\n            boundsTraverseOrder: (box) => {\n              return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n            },\n            intersectsBounds: (box, isLeaf, score) => {\n              return score < closestDistance && score < maxThreshold;\n            },\n            intersectsRange: (otherOffset, otherCount) => {\n              for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                setTriangle(triangle2, i2, otherIndex, otherPos);\n                triangle2.a.applyMatrix4(geometryToBvh);\n                triangle2.b.applyMatrix4(geometryToBvh);\n                triangle2.c.applyMatrix4(geometryToBvh);\n                triangle2.needsUpdate = true;\n                for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                  setTriangle(triangle, i, index, pos);\n                  triangle.needsUpdate = true;\n                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                  if (dist < closestDistance) {\n                    tempTargetDest1.copy(tempTarget1);\n                    if (tempTargetDest2) {\n                      tempTargetDest2.copy(tempTarget2);\n                    }\n                    closestDistance = dist;\n                    closestDistanceTriIndex = i / 3;\n                    closestDistanceOtherTriIndex = i2 / 3;\n                  }\n                  if (dist < minThreshold) {\n                    return true;\n                  }\n                }\n              }\n            }\n          });\n        } else {\n          const triCount = otherIndex ? otherIndex.count : otherPos.count;\n          for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, otherIndex, otherPos);\n            triangle2.a.applyMatrix4(geometryToBvh);\n            triangle2.b.applyMatrix4(geometryToBvh);\n            triangle2.c.applyMatrix4(geometryToBvh);\n            triangle2.needsUpdate = true;\n            for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n              setTriangle(triangle, i, index, pos);\n              triangle.needsUpdate = true;\n              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n              if (dist < closestDistance) {\n                tempTargetDest1.copy(tempTarget1);\n                if (tempTargetDest2) {\n                  tempTargetDest2.copy(tempTarget2);\n                }\n                closestDistance = dist;\n                closestDistanceTriIndex = i / 3;\n                closestDistanceOtherTriIndex = i2 / 3;\n              }\n              if (dist < minThreshold) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity)\n      return null;\n    if (!target1.point)\n      target1.point = tempTargetDest1.clone();\n    else\n      target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n      if (!target2.point)\n        target2.point = tempTargetDest2.clone();\n      else\n        target2.point.copy(tempTargetDest2);\n      target2.point.applyMatrix4(tempMatrix);\n      tempTargetDest1.applyMatrix4(tempMatrix);\n      target2.distance = tempTargetDest1.sub(target2.point).length();\n      target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n  }\n  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    this.shapecast({\n      boundsTraverseOrder: (box) => {\n        temp.copy(point).clamp(box.min, box.max);\n        return temp.distanceToSquared(point);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        return score < closestDistanceSq && score < maxThresholdSq;\n      },\n      intersectsTriangle: (tri, triIndex) => {\n        tri.closestPointToPoint(point, temp);\n        const distSq = point.distanceToSquared(temp);\n        if (distSq < closestDistanceSq) {\n          temp1.copy(temp);\n          closestDistanceSq = distSq;\n          closestDistanceTriIndex = triIndex;\n        }\n        if (distSq < minThresholdSq) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    });\n    if (closestDistanceSq === Infinity)\n      return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point)\n      target.point = temp1.clone();\n    else\n      target.point.copy(temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n  }\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach((buffer) => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n}\nconst originalRaycast = MeshBVH.prototype.raycast;\nMeshBVH.prototype.raycast = function(...args) {\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.');\n    const [mesh, raycaster, ray, intersects] = args;\n    const results = originalRaycast.call(this, ray, mesh.material);\n    results.forEach((hit) => {\n      hit = convertRaycastIntersect(hit, mesh, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    });\n    return intersects;\n  } else {\n    return originalRaycast.apply(this, args);\n  }\n};\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\nMeshBVH.prototype.raycastFirst = function(...args) {\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.');\n    const [mesh, raycaster, ray] = args;\n    return convertRaycastIntersect(originalRaycastFirst.call(this, ray, mesh.material), mesh, raycaster);\n  } else {\n    return originalRaycastFirst.apply(this, args);\n  }\n};\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\nMeshBVH.prototype.closestPointToPoint = function(...args) {\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.');\n    args.unshift();\n    const target = args[1];\n    const result = {};\n    args[1] = result;\n    originalClosestPointToPoint.apply(this, args);\n    if (target) {\n      target.copy(result.point);\n    }\n    return result.distance;\n  } else {\n    return originalClosestPointToPoint.apply(this, args);\n  }\n};\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\nMeshBVH.prototype.closestPointToGeometry = function(...args) {\n  const target1 = args[2];\n  const target2 = args[3];\n  if (target1 && target1.isVector3 || target2 && target2.isVector3) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.');\n    const result1 = {};\n    const result2 = {};\n    const geometryToBvh = args[1];\n    args[2] = result1;\n    args[3] = result2;\n    originalClosestPointToGeometry.apply(this, args);\n    if (target1) {\n      target1.copy(result1.point);\n    }\n    if (target2) {\n      target2.copy(result2.point).applyMatrix4(geometryToBvh);\n    }\n    return result1.distance;\n  } else {\n    return originalClosestPointToGeometry.apply(this, args);\n  }\n};\nconst originalRefit = MeshBVH.prototype.refit;\nMeshBVH.prototype.refit = function(...args) {\n  const nodeIndices = args[0];\n  const terminationIndices = args[1];\n  if (terminationIndices && (terminationIndices instanceof Set || Array.isArray(terminationIndices))) {\n    console.warn('MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.');\n    const newNodeIndices = /* @__PURE__ */ new Set();\n    terminationIndices.forEach((v) => newNodeIndices.add(v));\n    if (nodeIndices) {\n      nodeIndices.forEach((v) => newNodeIndices.add(v));\n    }\n    originalRefit.call(this, newNodeIndices);\n  } else {\n    originalRefit.apply(this, args);\n  }\n};\n[\n  \"intersectsGeometry\",\n  \"shapecast\",\n  \"intersectsBox\",\n  \"intersectsSphere\"\n].forEach((name) => {\n  const originalFunc = MeshBVH.prototype[name];\n  MeshBVH.prototype[name] = function(...args) {\n    if (args[0] === null || args[0].isMesh) {\n      args.shift();\n      console.warn(`MeshBVH: The function signature for \"${name}\" has changed and no longer takes Mesh. See docs for new signature.`);\n    }\n    return originalFunc.apply(this, args);\n  };\n});\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootVisualizer extends Object3D {\n  get isMesh() {\n    return !this.displayEdges;\n  }\n  get isLineSegments() {\n    return this.displayEdges;\n  }\n  get isLine() {\n    return this.displayEdges;\n  }\n  constructor(mesh, material, depth = 10, group = 0) {\n    super();\n    this.material = material;\n    this.geometry = new BufferGeometry();\n    this.name = \"MeshBVHRootVisualizer\";\n    this.depth = depth;\n    this.displayParents = false;\n    this.mesh = mesh;\n    this.displayEdges = true;\n    this._group = group;\n  }\n  raycast() {\n  }\n  update() {\n    const geometry = this.geometry;\n    const boundsTree = this.mesh.geometry.boundsTree;\n    const group = this._group;\n    geometry.dispose();\n    this.visible = false;\n    if (boundsTree) {\n      const targetDepth = this.depth - 1;\n      const displayParents = this.displayParents;\n      let boundsCount = 0;\n      boundsTree.traverse((depth, isLeaf) => {\n        if (depth === targetDepth || isLeaf) {\n          boundsCount++;\n          return true;\n        } else if (displayParents) {\n          boundsCount++;\n        }\n      }, group);\n      let posIndex = 0;\n      const positionArray = new Float32Array(8 * 3 * boundsCount);\n      boundsTree.traverse((depth, isLeaf, boundingData) => {\n        const terminate = depth === targetDepth || isLeaf;\n        if (terminate || displayParents) {\n          arrayToBox(0, boundingData, boundingBox);\n          const { min, max } = boundingBox;\n          for (let x = -1; x <= 1; x += 2) {\n            const xVal = x < 0 ? min.x : max.x;\n            for (let y = -1; y <= 1; y += 2) {\n              const yVal = y < 0 ? min.y : max.y;\n              for (let z = -1; z <= 1; z += 2) {\n                const zVal = z < 0 ? min.z : max.z;\n                positionArray[posIndex + 0] = xVal;\n                positionArray[posIndex + 1] = yVal;\n                positionArray[posIndex + 2] = zVal;\n                posIndex += 3;\n              }\n            }\n          }\n          return terminate;\n        }\n      }, group);\n      let indexArray;\n      let indices;\n      if (this.displayEdges) {\n        indices = new Uint8Array([\n          0,\n          4,\n          1,\n          5,\n          2,\n          6,\n          3,\n          7,\n          0,\n          2,\n          1,\n          3,\n          4,\n          6,\n          5,\n          7,\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7\n        ]);\n      } else {\n        indices = new Uint8Array([\n          0,\n          1,\n          2,\n          2,\n          1,\n          3,\n          4,\n          6,\n          5,\n          6,\n          7,\n          5,\n          1,\n          4,\n          5,\n          0,\n          4,\n          1,\n          2,\n          3,\n          6,\n          3,\n          7,\n          6,\n          0,\n          2,\n          4,\n          2,\n          6,\n          4,\n          1,\n          5,\n          3,\n          3,\n          5,\n          7\n        ]);\n      }\n      if (positionArray.length > 65535) {\n        indexArray = new Uint32Array(indices.length * boundsCount);\n      } else {\n        indexArray = new Uint16Array(indices.length * boundsCount);\n      }\n      const indexLength = indices.length;\n      for (let i = 0; i < boundsCount; i++) {\n        const posOffset = i * 8;\n        const indexOffset = i * indexLength;\n        for (let j = 0; j < indexLength; j++) {\n          indexArray[indexOffset + j] = posOffset + indices[j];\n        }\n      }\n      geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n      geometry.setAttribute(\"position\", new BufferAttribute(positionArray, 3, false));\n      this.visible = true;\n    }\n  }\n}\nclass MeshBVHVisualizer extends Group {\n  get color() {\n    return this.edgeMaterial.color;\n  }\n  get opacity() {\n    return this.edgeMaterial.opacity;\n  }\n  set opacity(v) {\n    this.edgeMaterial.opacity = v;\n    this.meshMaterial.opacity = v;\n  }\n  constructor(mesh, depth = 10) {\n    super();\n    this.name = \"MeshBVHVisualizer\";\n    this.depth = depth;\n    this.mesh = mesh;\n    this.displayParents = false;\n    this.displayEdges = true;\n    this._roots = [];\n    const edgeMaterial = new LineBasicMaterial({\n      color: 65416,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    const meshMaterial = new MeshBasicMaterial({\n      color: 65416,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    this.edgeMaterial = edgeMaterial;\n    this.meshMaterial = meshMaterial;\n    this.update();\n  }\n  update() {\n    const bvh = this.mesh.geometry.boundsTree;\n    const totalRoots = bvh ? bvh._roots.length : 0;\n    while (this._roots.length > totalRoots) {\n      this._roots.pop();\n    }\n    for (let i = 0; i < totalRoots; i++) {\n      if (i >= this._roots.length) {\n        const root2 = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n        this.add(root2);\n        this._roots.push(root2);\n      }\n      const root = this._roots[i];\n      root.depth = this.depth;\n      root.mesh = this.mesh;\n      root.displayParents = this.displayParents;\n      root.displayEdges = this.displayEdges;\n      root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n      root.update();\n    }\n  }\n  updateMatrixWorld(...args) {\n    this.position.copy(this.mesh.position);\n    this.rotation.copy(this.mesh.rotation);\n    this.scale.copy(this.mesh.scale);\n    super.updateMatrixWorld(...args);\n  }\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n  }\n  clone() {\n    return new MeshBVHVisualizer(this.mesh, this.depth);\n  }\n  dispose() {\n    this.edgeMaterial.dispose();\n    this.meshMaterial.dispose();\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].geometry.dispose();\n    }\n  }\n}\nMesh.prototype.raycast;\nconst bvhManagerMap = /* @__PURE__ */ new WeakMap();\nvar computeBVH = (item) => {\n  item.outerObject3d.updateMatrixWorld(true);\n  const geometries = [];\n  item.outerObject3d.traverse((c) => {\n    if (!c.geometry || c === getObject3d(item) && !(item instanceof Primitive))\n      return;\n    const geom = c.geometry.clone();\n    geom.applyMatrix4(c.matrixWorld);\n    geometries.push(geom);\n    geom.dispose();\n  });\n  const bvhComputed = [];\n  for (const geom of geometries) {\n    const bvh = geom.boundsTree = new MeshBVH(geom);\n    bvhComputed.push(bvh);\n    bvhManagerMap.set(bvh, item);\n  }\n  return [bvhComputed, geometries];\n};\nexport { MeshBVHVisualizer as M, bvhManagerMap as b, computeBVH as c };\n"],"names":["__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","MeshBVHNode","constructor","arrayToBox","nodeIndex32","array","target","min","x","y","z","max","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","Infinity","i","dist","copyBounds","source","set","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","ensureIndex","geo","options","index","vertexCount","attributes","position","count","BufferConstructor","useSharedArrayBuffer","SharedArrayBuffer","ArrayBuffer","Uint32Array","Uint16Array","setIndex","BufferAttribute","getRootIndexRanges","groups","length","offset","ranges","rangeBoundaries","Set","group","add","start","sortedBoundaries","Array","from","values","sort","end","push","getBounds","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","partition","split","left","right","pos","axisOffset","axis","t0","t1","t2","BIN_COUNT","binsSort","candidate","sahBins","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","truncatedBins","c","bin","splitCount","bi","splice","center","leftCount","rightCount","leftBounds2","rightBounds","leftProb","rightProb","cost","triCenter","relativeCenter","binIndex","lastBin","nextBin","binCount","console","warn","avg","computeTriangleBounds","fullBounds","posAttr","posArr","triCount","bufferOffset","stride","isInterleavedBufferAttribute","data","tri","tri3","tri6","ai","ci","el","halfExtents","el2","abs","buildTree","triggerProgress","trianglesProcessed","onProgress","totalTriangles","splitNode","node","depth","reachedMaxDepth","maxDepth","verbose","maxLeafTris","boundingData","splitOffset","indexArray","splitAxis","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","roots","range","root","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","nodeCount","countNodes","buffer","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Error","SeparatingAxisBounds","this","setFromPointsField","points","field","l","p","val","setFromPoints","dot","isSeparated","other","setFromBox","Vector3","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","d1010","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp12","temp22","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","closestPoint1","distanceTo","closestPoint3","plane","getPlane","dp","distanceToPoint","pp","projectPoint","cp","containsPoint","SeparatingAxisTriangle","Triangle","args","super","isSeparatingAxisTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","plane1","plane2","normal","points1","found1","p1","intersectLine","points2","found2","delta","tmp","point","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","Box3","isOrientedBox","matrix","Matrix4","invMatrix","alignedSatBounds","v","applyMatrix4","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields2","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","f1","f2","f3","vA","vB","vC","uvA","uvB","uvC","intersectionPoint","checkIntersection","ray","pA","pB","pC","side","intersect","BackSide","intersectTriangle","DoubleSide","distance","origin","clone","checkBufferGeometryIntersection","uv","fromBufferAttribute","intersection","face","materialIndex","faceIndex","intersectTri","intersections","triOffset","getX","intersectTris","intersectClosestTri","res","convertRaycastIntersect","hit","object","raycaster","matrixWorld","near","far","setTriangle","ta","tb","tc","i0","getY","getZ","iterateOverTriangles","geometry","intersectsTriangleFunc","contained","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","BOUNDING_DATA_INDEX","boundingBox$1","boxIntersection","xyzFields","raycast","intersects","nodeIndex16","_float32Array","_uint16Array","_uint32Array","leftIndex","intersectRay","rightIndex","raycastFirst","xyzAxis","rayDir","direction","leftToRight","c1","c2","c1Intersection","c1Result","isOutside","c2Intersection","c2Result","shapecast","_box1","_box2","boxStack","boxPool","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","nodeIndex322","nodeIndex162","uint16Array2","uint32Array2","getRightEndOffset","score1","score2","box1","box2","temp5","isC1Leaf","c1StopTraversal","isC2Leaf","c2StopTraversal","intersectsGeometry","triangle2","invertedMat","obb3","obb22","intersectsGeometry2","otherGeometry","geometryToBvh","cachedObb","boundingBox","computeBoundingBox","leftIntersection","rightIntersection","thisGeometry","thisIndex","thisPos","boundsTree","intersectsBounds","intersectBox","bufferStack","_prevBuffer","setBuffer","clearBuffer","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","obb","obb2","temp","temp1","temp2","temp3","temp4","tempBox","trianglePool","MeshBVH","bvh","isBufferGeometry","serialize","arguments","cloneBuffers","rootData","_roots","indexAttribute","getIndex","slice","deserialize","newIndex","assign","setBoundingBox","getBoundingBox","refit","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","byteOffset2","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","stopTraversal","materialOrSide","FrontSide","isMaterial","isArrayMaterial","materialSide","startCount","j","jl","closestResult","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","i3","boundsTraverseOrder","intersectsRange","originalIntersectsRange","nodeIndex","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","contained2","nodeIndex2","boxToMesh","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","forEach","union","originalRaycast","isMesh","mesh","results","material","apply","originalRaycastFirst","originalClosestPointToPoint","unshift","originalClosestPointToGeometry","isVector3","result1","result2","originalRefit","terminationIndices","newNodeIndices","name","originalFunc","shift","MeshBVHRootVisualizer","Object3D","displayEdges","isLineSegments","isLine","BufferGeometry","displayParents","_group","dispose","visible","targetDepth","boundsCount","posIndex","positionArray","indices","terminate","xVal","yVal","zVal","Uint8Array","indexLength","posOffset","indexOffset","setAttribute","MeshBVHVisualizer","Group","color","edgeMaterial","opacity","meshMaterial","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","root2","updateMatrixWorld","rotation","scale","children","Mesh","bvhManagerMap","WeakMap","computeBVH","item","outerObject3d","geometries","getObject3d","Primitive","geom","bvhComputed"],"sourceRoot":""}